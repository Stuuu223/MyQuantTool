# V12.1.0 执行计划

> **版本**: V12.1.0 [Shihuang Edition]  
> **创建日期**: 2026-02-14  
> **CTO**: iFlow CLI  
> **状态**: 待执行  
> **目标**: 提升胜率从 22% 到 35%+，降低最大回撤到 -2.0% 以下

---

## 📊 执行背景

### 现状评估

**回测结果（V11.0）**：
- 总收益率：+9.42% ✅
- 胜率：22.73% ⚠️（核心问题）
- 最大回撤：-2.76% ✅
- 交易次数：66次/月 ⚠️（偏高）
- 盈亏比：6.71 ✅

**核心问题诊断**：
- **高盈亏比、低胜率**：每做5笔交易就要忍受4次止损，实盘心态极难坚持
- **交易频率偏高**：缺乏持仓时间限制，容易被洗盘
- **止损占主导**：77.27%的交易因止损卖出，需要优化止损策略

### CTO 核心裁决

> "基建已成，策略待兴。回测结果（胜率 22%）像一把悬在头顶的达摩克利斯之剑，提醒我们必须立即在策略逻辑上动'大手术'。"

---

## 🎯 V12.1.0 目标

| 指标 | V11.0现状 | V12.1.0目标 | 提升 | 验收标准 |
|------|-----------|-------------|------|----------|
| 胜率 | 22.73% | 35%+ | +54% | >=35% |
| 最大回撤 | -2.76% | -2.0% | -28% | <= -2.0% |
| 交易频率 | 66次/月 | 40-50次/月 | -30% | <=50次/月 |
| 盈亏比 | 6.71 | 5.0+ | 维持 | >=5.0 |

---

## 🚀 执行策略：先磨刀，再砍柴

### 为什么先做报告系统？

CTO 原话：
> "你切中了要害！没有详细的诊断报告，优化就是盲人摸象。"

**核心原因**：
1. **精准定位问题**：需要知道哪种策略亏损最多、何时亏钱、为什么亏
2. **验证优化效果**：没有基准线，无法判断优化是否有效
3. **加速迭代**：可视化报告能快速发现问题，加快优化迭代

---

## 📋 执行步骤总览

```
Phase 1: 磨刀（报告系统）          [预计 2-3 天]
    ↓
Phase 2: 定位（问题诊断）          [预计 1 天]
    ↓
Phase 3: 砍柴（优化策略）          [预计 10-14 天]
    ↓
Phase 4: 验证（效果对比）          [预计 2-3 天]
```

---

## Phase 1: 磨刀（报告系统）[2-3天]

### 目标

构建回测诊断系统，为后续优化提供精准的度量工具。

### 任务列表

#### 任务1.1: 创建回测报告生成器 [1-2天]

**文件**: `logic/backtest_report_generator.py`

**核心功能**:
```python
class BacktestReportGenerator:
    def __init__(self, result_file: str):
        """初始化报告生成器"""
        self.result_file = result_file
        self.result = self._load_result()
        self.trades_df = pd.DataFrame(self.result['trades'])
        self.equity_df = pd.DataFrame(self.result['equity_curve'])
    
    def generate_dashboard(self) -> str:
        """生成核心仪表盘"""
        # 1. 净值曲线图（matplotlib）
        # 2. 回撤分析图
        # 3. 收益分布直方图
        # 4. 关键指标表格
        pass
    
    def generate_strategy_attribution(self) -> str:
        """生成策略归因分析"""
        # 1. 按策略分类统计胜率
        # 2. 按策略分类统计盈亏比
        # 3. 策略对比柱状图
        # 4. 策略贡献度分析
        pass
    
    def generate_failure_autopsy(self) -> str:
        """生成失败案例尸检"""
        # 1. 亏损额最大的5笔交易
        # 2. 止损原因分布
        # 3. 亏损幅度分布
        # 4. 亏损单共同特征
        pass
    
    def generate_full_report(self, output_path: str):
        """生成完整报告"""
        dashboard = self.generate_dashboard()
        attribution = self.generate_strategy_attribution()
        autopsy = self.generate_failure_autopsy()
        
        report = f"""
# 回测诊断报告

## 核心仪表盘
{dashboard}

## 策略归因分析
{attribution}

## 失败案例尸检
{autopsy}
"""
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(report)
```

**验收标准**:
- [ ] 能够读取JSON回测结果
- [ ] 生成净值曲线图（PNG）
- [ ] 生成策略归因分析（表格）
- [ ] 生成失败案例尸检（表格）
- [ ] 生成Markdown报告

#### 任务1.2: 创建分析工具脚本 [0.5天]

**文件**: `tools/analyze_backtest_result.py`

**核心功能**:
```python
def analyze_backtest_result(result_file: str):
    """分析回测结果"""
    # 1. 加载JSON结果
    # 2. 计算基础指标
    # 3. 按策略分类统计
    # 4. 生成Markdown报告
    pass

if __name__ == "__main__":
    result_file = "backtest/results/comprehensive_backtest_20260214_154734.json"
    analyze_backtest_result(result_file)
```

**验收标准**:
- [ ] 能够独立运行
- [ ] 输出Markdown报告
- [ ] 包含策略分类胜率
- [ ] 包含亏损单特征分析

#### 任务1.3: 运行分析现有回测结果 [0.5天]

**执行命令**:
```bash
python tools/analyze_backtest_result.py
```

**预期输出**:
- 报告文件：`backtest/results/backtest_diagnosis_20260214.md`
- 包含：
  - 策略分类胜率对比
  - 亏损单特征分析
  - 优化建议

---

## Phase 2: 定位（问题诊断）[1天]

### 目标

基于回测诊断报告，精准定位问题根源。

### 任务列表

#### 任务2.1: 审阅诊断报告 [0.5天]

**关注点**:
1. **哪种策略亏损最多？**
   - 龙头战法胜率？
   - 半路战法胜率？
   - 时机斧胜率？

2. **何时亏钱？**
   - 早盘追高回落？
   - 尾盘跳水？
   - 特定时间？

3. **为什么亏钱？**
   - 买入后即套？
   - 持仓时间过短？
   - 止损太紧？

#### 任务2.2: 制定优化策略 [0.5天]

**输出**: `V12.1.0_OPTIMIZATION_STRATEGY.md`

**内容**:
1. 问题诊断结论
2. 优化优先级排序
3. 具体优化方案
4. 预期效果评估

---

## Phase 3: 砍柴（优化策略）[10-14天]

### 目标

基于诊断结果，实施三大过滤器，提升胜率。

### 任务列表

#### 任务3.1: 开发板块共振过滤器 [3-4天]

**文件**: `logic/strategies/wind_filter.py`

**核心逻辑**:
```python
class WindFilter:
    """
    风口过滤器：基于板块共振增强
    """
    
    def check_sector_resonance(self, stock_code):
        """
        检查板块共振状态
        Returns:
            {
                "is_resonance": bool,  # 是否共振
                "limit_up_count": int,  # 涨停股数
                "breadth": float,  # 上涨比例
                "sustained_inflow": bool,  # 持续流入
                "resonance_score": float  # 共振分数（0-1）
            }
        """
        sector = get_sector(stock_code)
        
        # 条件1：板块内涨停股≥3只
        limit_up_count = count_limit_up_in_sector(sector)
        
        # 条件2：板块内上涨股票占比≥35%
        up_count = count_up_stocks_in_sector(sector)
        total_count = count_total_stocks_in_sector(sector)
        breadth = up_count / total_count if total_count > 0 else 0
        
        # 条件3：板块指数连续3日资金净流入
        sector_index_flow = get_sector_index_flow(sector, days=3)
        sustained_inflow = all(flow > 0 for flow in sector_index_flow)
        
        # CTO要求：满足至少2个条件才返回True
        condition_count = sum([
            limit_up_count >= 3,
            breadth >= 0.35,
            sustained_inflow
        ])
        
        is_resonance = condition_count >= 2
        
        return {
            "is_resonance": is_resonance,
            "limit_up_count": limit_up_count,
            "breadth": breadth,
            "sustained_inflow": sustained_inflow,
            "resonance_score": self._calculate_resonance_score(
                limit_up_count, breadth, sustained_inflow
            )
        }
```

**验收标准**:
- [ ] 板块共振准确率>80%（基于历史数据验证）
- [ ] 共振状态下胜率>40%（未共振时<25%）
- [ ] 单次判断耗时<100ms

#### 任务3.2: 开发动态阈值管理器 [3-4天]

**文件**: `logic/strategies/dynamic_threshold.py`

**核心逻辑**:
```python
class DynamicThreshold:
    """
    动态阈值管理器
    """
    
    def calculate_thresholds(self, stock_code, current_time, sentiment_stage):
        """
        动态计算阈值
        Returns:
            {
                "pct_chg_min": float,  # 最小涨幅
                "volume_ratio_min": float, # 最小量比
                "turnover_min": float,  # 最小换手率
                "main_inflow_min": float,  # 最小主力流入
                "risk_score_max": float  # 最大风险评分
            }
        """
        # 废弃硬编码，采用动态计算
        
        # 方案1：按市值比例
        cap = self.get_circulating_cap(stock_code)
        if cap < 50_0000_0000:  # 50亿以下
            ratio = 0.002  # 0.2%
        elif cap > 100_000_000_000:  # 1000亿以上
            ratio = 0.0005  # 0.05%
        else:
            ratio = 0.001  # 0.1%
        
        main_inflow_min = cap * ratio
        
        # 方案2：按昨日成交额
        yesterday_amount = self.get_yesterday_amount(stock_code)
        main_inflow_min = yesterday_amount * 0.01
        
        # 时间分段调整
        hour = current_time.hour
        if 9 <= hour < 10:  # 开盘阶段
            pct_chg_min *= 0.8  # 放宽
        elif 14 <= hour < 15:  # 尾盘阶段
            pct_chg_min *= 1.2  # 严格
        
        # 情绪周期调整
        if sentiment_stage in ['启动', '主升', '高潮']:
            risk_score_max *= 0.8  # 激进
        elif sentiment_stage in ['退潮', '冰点']:
            risk_score_max *= 1.2  # 保守
        
        return {
            "pct_chg_min": pct_chg_min,
            "volume_ratio_min": volume_ratio_min,
            "turnover_min": turnover_min,
            "main_inflow_min": main_inflow_min,
            "risk_score_max": risk_score_max
        }
```

**验收标准**:
- [ ] 动态阈值准确反映市场状态
- [ ] 不同市值股票阈值合理
- [ ] 单次计算耗时<50ms

#### 任务3.3: 开发竞价强弱校验器 [2-3天]

**文件**: `logic/strategies/auction_strength_validator.py`

**核心逻辑**:
```python
class AuctionStrengthValidator:
    """
    竞价强弱校验器
    """
    
    def validate_auction(self, stock_code, auction_data, is_focus_stock=False):
        """
        验证竞价强弱
        Returns:
            {
                "is_valid": bool,
                "reason": str,
                "action": str,  # STRONG_BUY/BUY/WATCH
                "confidence": float
            }
        """
        # 计算预期
        yesterday_strength = self._get_yesterday_strength(stock_code)
        expectation = yesterday_strength * 0.1
        
        # 计算实际
        actual_open = self._calculate_open_premium(auction_data)
        volume_ratio = auction_data.get('volume_ratio', 0)
        
        # 明牌焦点股：竞价不能超预期 → 打折扣
        if is_focus_stock:
            if actual_open > expectation:
                return {
                    "is_valid": False,
                    "reason": "明牌焦点股，竞价超预期，打折扣",
                    "action": "WATCH",
                    "confidence": 0.0
                }
        
        # 非明牌股：竞价超预期 + 量比>2 → STRONG_BUY
        if actual_open > 0.01 and actual_open < 0.03 and volume_ratio > 2.0:
            return {
                "is_valid": True,
                "reason": "竞价爆量跳空高开",
                "action": "STRONG_BUY",
                "confidence": 0.85
            }
        
        # 基础判定：量比+涨幅配合
        if volume_ratio > 1.5 and actual_open > 0.02:
            return {
                "is_valid": True,
                "reason": "量比排序+涨幅排序配合",
                "action": "BUY",
                "confidence": 0.70
            }
        
        return {
            "is_valid": False,
            "reason": "竞价强度不足",
            "action": "WATCH",
            "confidence": 0.0
        }
```

**验收标准**:
- [ ] 竞价信号准确率>75%
- [ ] 能够区分明牌股和非明牌股
- [ ] 单次验证耗时<30ms

#### 任务3.4: 集成三大过滤器 [2-3天]

**文件**: `logic/strategies/triple_funnel_scanner.py`

**修改内容**:
```python
from logic.strategies.wind_filter import WindFilter
from logic.strategies.dynamic_threshold import DynamicThreshold
from logic.strategies.auction_strength_validator import AuctionStrengthValidator

class TripleFunnelScanner:
    def __init__(self, config):
        # 初始化三大过滤器
        self.wind_filter = WindFilter()
        self.dynamic_threshold = DynamicThreshold()
        self.auction_validator = AuctionStrengthValidator()
    
    def _apply_filters(self, stock_code, tick_data, flow_data, auction_data):
        """
        应用三大过滤器
        """
        # 过滤器1：风口过滤器（板块共振）
        wind_result = self.wind_filter.check_sector_resonance(stock_code)
        if not wind_result['is_resonance']:
            return {
                "is_passed": False,
                "reason": f"板块未满足共振条件: 涨停{wind_result['limit_up_count']}只, 上涨{wind_result['breadth']*100:.1f}%"
            }
        
        # 过滤器2：动态阈值过滤器
        current_time = datetime.now()
        sentiment_stage = self._get_sentiment_stage()
        threshold_result = self.dynamic_threshold.calculate_thresholds(
            stock_code, current_time, sentiment_stage
        )
        
        # 检查涨幅是否达标
        pct_chg = self._calculate_pct_chg(tick_data)
        if pct_chg < threshold_result['pct_chg_min']:
            return {
                "is_passed": False,
                "reason": f"涨幅未达到阈值（需要>{threshold_result['pct_chg_min']:.2f}%，实际{pct_chg:.2f}%）"
            }
        
        # 过滤器3：竞价强弱校验器（仅开盘阶段使用）
        hour = current_time.hour
        if 9 <= hour < 10:  # 开盘阶段
            auction_result = self.auction_validator.validate_auction(
                stock_code, auction_data, is_focus_stock=False
            )
            if not auction_result['is_valid']:
                return {
                    "is_passed": False,
                    "reason": f"竞价强度不足: {auction_result['reason']}"
                }
        
        # 所有过滤器通过
        return {
            "is_passed": True,
            "reason": "所有过滤器通过",
            "wind_result": wind_result,
            "threshold_result": threshold_result,
            "auction_result": auction_result if hour < 10 else None
        }
    
    def scan_market(self):
        """
        扫描全市场
        """
        results = []
        
        for stock_code in all_stocks:
            # 获取数据
            tick_data = self._get_tick_data(stock_code)
            flow_data = self._get_flow_data(stock_code)
            auction_data = self._get_auction_data(stock_code)
            
            # 应用三大过滤器
            filter_result = self._apply_filters(stock_code, tick_data, flow_data, auction_data)
            
            if not filter_result['is_passed']:
                # 未通过过滤器，记录到观察池
                results.append({
                    "code": stock_code,
                    "tag": "WATCH",
                    "reason": filter_result['reason'],
                    "filter_result": filter_result
                })
                continue
            
            # 通过过滤器，继续三把斧决策
            decision_result = self._apply_triple_funnel(stock_code, tick_data, flow_data)
            
            results.append({
                "code": stock_code,
                "tag": decision_result['tag'],
                "reason": decision_result['reason'],
                "filter_result": filter_result,
                "funnel_result": decision_result
            })
        
        return results
```

**验收标准**:
- [ ] 所有过滤器正常工作
- [ ] 过滤结果可追溯
- [ ] 集成不影响原有功能

---

## Phase 4: 验证（效果对比）[2-3天]

### 目标

对比V11.0和V12.1.0，验证优化效果。

### 任务列表

#### 任务4.1: 创建对比回测脚本 [1天]

**文件**: `backtest/compare_v11_vs_v121.py`

**核心功能**:
```python
class BacktestComparator:
    def run_comparison(self, start_date, end_date):
        """
        运行对比回测
        """
        # 运行V11.0版本
        v11_results = self._run_backtest(version='v11')
        
        # 运行V12.1.0版本
        v121_results = self._run_backtest(version='v121')
        
        # 对比结果
        comparison = self._compare_results(v11_results, v121_results)
        
        # 生成报告
        self._generate_report(comparison)
        
        return comparison
    
    def _compare_results(self, v11_results, v121_results):
        """
        对比两个版本的结果
        """
        return {
            "total_return": {
                "v11": v11_results['metrics']['total_return'],
                "v121": v121_results['metrics']['total_return'],
                "improvement": v121_results['metrics']['total_return'] - v11_results['metrics']['total_return']
            },
            "max_drawdown": {
                "v11": v11_results['metrics']['max_drawdown'],
                "v121": v121_results['metrics']['max_drawdown'],
                "improvement": v11_results['metrics']['max_drawdown'] - v121_results['metrics']['max_drawdown']
            },
            "win_rate": {
                "v11": v11_results['metrics']['win_rate'],
                "v121": v121_results['metrics']['win_rate'],
                "improvement": v121_results['metrics']['win_rate'] - v11_results['metrics']['win_rate']
            },
            "trade_count": {
                "v11": v11_results['metrics']['total_trades'],
                "v121": v121_results['metrics']['total_trades'],
                "reduction": v11_results['metrics']['total_trades'] - v121_results['metrics']['total_trades']
            }
        }
```

**验收标准**:
- [ ] 能够对比两个版本
- [ ] 生成对比报告
- [ ] 验收标准明确

#### 任务4.2: 运行对比回测 [1天]

**执行命令**:
```bash
python backtest/compare_v11_vs_v121.py
```

**预期输出**:
- 对比报告：`backtest/results/comparison_v11_vs_v121_20260214.md`
- 包含：
  - 核心指标对比
  - 策略分类对比
  - 优化效果评估

#### 任务4.3: 审核优化效果 [0.5天]

**验收标准检查**:
- [ ] 胜率提升>10%（从22.73%到35%+）
- [ ] 最大回撤降低>20%（从-2.76%到-2.0%以下）
- [ ] 交易次数减少>20%（从66次到40-50次）
- [ ] 盈亏比保持>5.0

**如果未达标**:
- 分析失败原因
- 调整过滤器参数
- 重新运行回测

---

## 📊 关键里程碑

| 里程碑 | 预计完成时间 | 验收标准 |
|--------|------------|----------|
| **M1: 报告系统上线** | Day 3 | 能够生成诊断报告 |
| **M2: 问题诊断完成** | Day 4 | 输出优化策略 |
| **M3: 板块共振过滤器** | Day 7 | 共振准确率>80% |
| **M4: 动态阈值管理器** | Day 11 | 单次计算<50ms |
| **M5: 竞价校验器** | Day 14 | 竞价准确率>75% |
| **M6: 三大过滤器集成** | Day 17 | 集成正常工作 |
| **M7: 对比回测完成** | Day 20 | 生成对比报告 |
| **M8: V12.1.0验收** | Day 21 | 所有指标达标 |

---

## ⚠️ 风险管理

### 风险1: 回测结果不完整

**描述**: 现有回测结果可能不完整，无法准确分析

**应对措施**:
- 使用历史快照数据进行回测
- 增加单元测试覆盖
- 验证数据加载流程

### 风险2: 过滤器过度限制

**描述**: 三大过滤器可能过于严格，导致交易频率过低

**应对措施**:
- 设计可调节的阈值参数
- 提供A/B测试能力
- 动态调整过滤强度

### 风险3: 开发周期超时

**描述**: 预计21天可能无法完成所有开发任务

**应对措施**:
- 优先完成P0任务（报告系统、板块共振）
- P1/P2任务可以延后到下一版本
- 保持最小可行性产品（MVP）

---

## 📝 验收标准（Definition of Done）

V12.1.0 开发完成的标志不是代码写完，而是回测数据达标：

- ✅ **胜率**: 从 22% 提升至 35% 以上
- ✅ **交易频率**: 从 66 次/月降至 30 次/月（去伪存真）
- ✅ **最大回撤**: 保持在 -5% 以内
- ✅ **盈亏比**: 保持 5.0 以上

---

## 🎯 下一步行动

**立即执行**（今天）：
1. [ ] 创建 `logic/backtest_report_generator.py`
2. [ ] 创建 `tools/analyze_backtest_result.py`
3. [ ] 运行分析现有回测结果

**本周完成**：
4. [ ] 生成诊断报告
5. [ ] 审阅报告，定位问题
6. [ ] 制定优化策略

**下周开始**：
7. [ ] 开发板块共振过滤器
8. [ ] 开发动态阈值管理器
9. [ ] 开发竞价校验器

---

**文档生成时间**: 2026-02-14  
**CTO**: iFlow CLI  
**状态**: 待执行  
**预计完成时间**: 2026-03-07