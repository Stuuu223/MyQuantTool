# -*- coding: utf-8 -*-
"""
ä¸‰æ¼æ–—æ‰«æç³»ç»Ÿ - å®Œæ•´æ¶æ„è®¾è®¡

ç³»ç»Ÿæ¶æ„ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ä¸‰æ¼æ–—æ‰«æç³»ç»Ÿæ¶æ„                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  ğŸ“Š æ¼æ–—1: ç›˜åç­›é€‰ (Level 1-3)                                 â”‚
â”‚  â”œâ”€ Level 1: åŸºç¡€è¿‡æ»¤ (ä»·æ ¼/æˆäº¤é‡/æŠ€æœ¯æŒ‡æ ‡)                    â”‚
â”‚  â”œâ”€ Level 2: èµ„é‡‘æµå‘åˆ†æ (DDE/ä¸»åŠ›èµ„é‡‘/æ¿å—çƒ­åº¦)                â”‚
â”‚  â””â”€ Level 3: é£é™©è¯„ä¼° (è¯±å¤šæ£€æµ‹/èµ„é‡‘æ€§è´¨/é£é™©è¯„åˆ†)               â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚                                                                 â”‚
â”‚  ğŸ¯ è§‚å¯Ÿæ±  (Watchlist Pool)                                     â”‚
â”‚  â”œâ”€ æ‰‹åŠ¨ç»´æŠ¤ (30-50åª)                                          â”‚
â”‚  â”œâ”€ ç›˜å‰è¡¥å…… (AkShareå¿«ç…§)                                      â”‚
â”‚  â””â”€ åŠ¨æ€è°ƒæ•´ (æ ¹æ®ç­›é€‰ç»“æœ)                                      â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚                                                                 â”‚
â”‚  âš¡ æ¼æ–—2: ç›˜ä¸­è§¦å‘ (Level 4)                                    â”‚
â”‚  â”œâ”€ Tickå®æ—¶ç›‘æ§ (VWAPçªç ´/æ‰«å•/ç«ä»·çˆ†é‡)                        â”‚
â”‚  â”œâ”€ ä¿¡å·å»é‡ (é¿å…é‡å¤è§¦å‘)                                      â”‚
â”‚  â””â”€ è‡ªåŠ¨é€šçŸ¥ (UIå¼¹çª—/æ—¥å¿—/é‚®ä»¶)                                  â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚                                                                 â”‚
â”‚  ğŸ® æ‰§è¡Œç³»ç»Ÿ (Execution System)                                 â”‚
â”‚  â”œâ”€ æ‰‹åŠ¨ç¡®è®¤ (UIå¼¹çª—)                                           â”‚
â”‚  â”œâ”€ è‡ªåŠ¨äº¤æ˜“ (QMTäº¤æ˜“æ¥å£)                                      â”‚
â”‚  â””â”€ äº¤æ˜“è®°å½• (decision_logs)                                    â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ ¸å¿ƒè®¾è®¡åŸåˆ™ï¼š
1. åˆ©ç”¨ç°æœ‰æ¶æ„ - å¤ç”¨ intraday_monitor, data_source_manager ç­‰æ¨¡å—
2. Tickä¼˜å…ˆ - å¦‚æœQMTæ”¯æŒTickå›è°ƒï¼Œä¼˜å…ˆä½¿ç”¨ï¼›å¦åˆ™è½®è¯¢
3. æ¸è¿›å¼ç­›é€‰ - ä»5000åªâ†’1000åªâ†’100åªâ†’30åªï¼Œé€å±‚è¿‡æ»¤
4. é£é™©æ§åˆ¶ - æ¯å±‚éƒ½æœ‰é£é™©æ£€æŸ¥ï¼Œé¿å…ä¹°å…¥é—®é¢˜è‚¡
5. å¯é…ç½®åŒ– - æ‰€æœ‰å‚æ•°éƒ½å¯é€šè¿‡é…ç½®æ–‡ä»¶è°ƒæ•´

æ•°æ®æµï¼š
[å…¨å¸‚åœº5000åª] â†’ Level1ç­›é€‰ â†’ [1000åª] â†’ Level2åˆ†æ â†’ [100åª] â†’
Level3é£é™©è¯„ä¼° â†’ [30åªè§‚å¯Ÿæ± ] â†’ Level4ç›˜ä¸­ç›‘æ§ â†’ [ä¿¡å·è§¦å‘] â†’ æ‰§è¡Œ

æŠ€æœ¯æ ˆï¼š
- ç›˜åæ•°æ®: AkShare (ä¸œæ–¹è´¢å¯Œ) + EasyQuotation (æ–°æµª)
- ç›˜ä¸­æ•°æ®: QMT (xtdata) æˆ– EasyQuotation (å¤‡ç”¨)
- é£é™©æ£€æµ‹: trap_detector.py + capital_classifier.py
- é…ç½®ç®¡ç†: config/watchlist_pool.json
- äº¤æ˜“æ¥å£: qmt_manager.py (å¦‚æœå¯ç”¨)

ä½œè€…: iFlow CLI
ç‰ˆæœ¬: V1.0
æ—¥æœŸ: 2026-02-05
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, time
from enum import Enum
from typing import Dict, List, Optional, Any, Tuple
import json
import numpy as np
import pandas as pd
from pathlib import Path

from logic.utils.logger import get_logger
from logic.utils.code_converter import CodeConverter
from logic.data_providers.data_source_manager import get_smart_data_manager
from logic.monitors.intraday_monitor import IntraDayMonitor
from logic.analyzers.trap_detector import TrapDetector
from logic.analyzers.capital_classifier import CapitalClassifier

logger = get_logger(__name__)


# ==================== æ•°æ®ç»“æ„å®šä¹‰ ====================

class TradingPhase(Enum):
    """äº¤æ˜“é˜¶æ®µ"""
    PRE_MARKET = "PRE_MARKET"           # ç›˜å‰ (09:00-09:25)
    OPENING_AUCTION = "OPENING_AUCTION" # å¼€ç›˜ç«ä»· (09:25-09:30)
    MORNING = "MORNING"                 # ä¸Šåˆ (09:30-11:30)
    LUNCH_BREAK = "LUNCH_BREAK"         # åˆä¼‘ (11:30-13:00)
    AFTERNOON = "AFTERNOON"             # ä¸‹åˆ (13:00-14:57)
    CLOSING_AUCTION = "CLOSING_AUCTION" # æ”¶ç›˜ç«ä»· (14:57-15:00)
    AFTER_HOURS = "AFTER_HOURS"         # æ”¶ç›˜å (15:00+)
    WEEKEND = "WEEKEND"                 # å‘¨æœ«


class SignalType(Enum):
    """ä¿¡å·ç±»å‹"""
    VWAP_BREAKOUT = "VWAP_BREAKOUT"       # VWAPçªç ´
    VOLUME_SURGE = "VOLUME_SURGE"         # æ‰«å•çˆ†é‡
    AUCTION_SPIKE = "AUCTION_SPIKE"       # ç«ä»·çˆ†é‡
    BREAKOUT_CONFIRM = "BREAKOUT_CONFIRM" # çªç ´ç¡®è®¤
    DIP_BUY = "DIP_BUY"                   # ä½å¸æœºä¼š


class RiskLevel(Enum):
    """é£é™©ç­‰çº§"""
    LOW = "LOW"       # ä½é£é™©
    MEDIUM = "MEDIUM" # ä¸­é£é™©
    HIGH = "HIGH"     # é«˜é£é™©
    CRITICAL = "CRITICAL" # ä¸¥é‡é£é™©


@dataclass
class StockBasicInfo:
    """è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯"""
    code: str
    name: str
    price: float
    pct_change: float
    volume: int
    amount: float
    turnover_rate: float
    high: float
    low: float
    open: float


@dataclass
class Level1Result:
    """Level 1 ç­›é€‰ç»“æœ"""
    code: str
    passed: bool
    reasons: List[str]
    metrics: Dict[str, Any]


@dataclass
class Level2Result:
    """Level 2 åˆ†æç»“æœ"""
    code: str
    passed: bool
    reasons: List[str]
    fund_flow_score: float  # èµ„é‡‘æµå‘å¾—åˆ† (0-100)
    sector_heat: float      # æ¿å—çƒ­åº¦ (0-100)
    metrics: Dict[str, Any]


@dataclass
class Level3Result:
    """Level 3 é£é™©è¯„ä¼°ç»“æœ"""
    code: str
    passed: bool
    risk_level: RiskLevel
    trap_risk: float       # è¯±å¤šé£é™© (0-1)
    capital_type: str      # èµ„é‡‘æ€§è´¨
    comprehensive_score: float # ç»¼åˆå¾—åˆ† (0-100)
    reasons: List[str]
    metrics: Dict[str, Any]


@dataclass
class WatchlistItem:
    """è§‚å¯Ÿæ± é¡¹"""
    code: str
    name: str
    reason: str
    level1_result: Optional[Level1Result] = None
    level2_result: Optional[Level2Result] = None
    level3_result: Optional[Level3Result] = None
    added_at: str = ""
    last_updated: str = ""


@dataclass
class TradingSignal:
    """äº¤æ˜“ä¿¡å·"""
    id: str
    stock_code: str
    stock_name: str
    signal_type: SignalType
    timestamp: str
    price: float
    trigger_price: float
    signal_strength: float  # ä¿¡å·å¼ºåº¦ (0-1)
    risk_level: RiskLevel
    details: Dict[str, Any]
    executed: bool = False
    execution_time: Optional[str] = None
    execution_price: Optional[float] = None


# ==================== æ¼æ–—1: ç›˜åç­›é€‰ ====================

class Level1Filter:
    """
    Level 1: åŸºç¡€è¿‡æ»¤
    
    è¿‡æ»¤æ¡ä»¶:
    - ä»·æ ¼åŒºé—´: 3-50å…ƒï¼ˆé¿å…ä½ä»·è‚¡å’Œé«˜ä»·è‚¡ï¼‰
    - æ¢æ‰‹ç‡: 2%-20%ï¼ˆé¿å…è¿‡å†·å’Œè¿‡çƒ­ï¼‰
    - æˆäº¤é‡: >1000ä¸‡ï¼ˆç¡®ä¿æµåŠ¨æ€§ï¼‰
    - æ’é™¤: STè‚¡ã€åœç‰Œè‚¡ã€æ–°è‚¡ã€é€€å¸‚æ•´ç†æœŸ
    """

    def __init__(self, config: Optional[Dict] = None):
        self.config = config or self._default_config()
        self.converter = CodeConverter()

    def _default_config(self) -> Dict:
        """é»˜è®¤é…ç½®"""
        return {
            "price_min": 3.0,
            "price_max": 50.0,
            "turnover_min": 2.0,
            "turnover_max": 20.0,
            "amount_min": 10000000,  # 1000ä¸‡
            "exclude_st": True,
            "exclude_suspended": True,
            "exclude_new": True,
        }

    def filter(self, stock_data: StockBasicInfo) -> Level1Result:
        """
        æ‰§è¡Œ Level 1 è¿‡æ»¤
        
        Args:
            stock_data: è‚¡ç¥¨åŸºæœ¬ä¿¡æ¯
        
        Returns:
            Level1Result: è¿‡æ»¤ç»“æœ
        """
        reasons = []
        metrics = {}
        passed = True

        # 1. ä»·æ ¼åŒºé—´
        metrics["price"] = stock_data.price
        if stock_data.price < self.config["price_min"]:
            passed = False
            reasons.append(f"ä»·æ ¼è¿‡ä½ ({stock_data.price:.2f} < {self.config['price_min']})")
        elif stock_data.price > self.config["price_max"]:
            passed = False
            reasons.append(f"ä»·æ ¼è¿‡é«˜ ({stock_data.price:.2f} > {self.config['price_max']})")

        # 2. æ¢æ‰‹ç‡
        metrics["turnover_rate"] = stock_data.turnover_rate
        if stock_data.turnover_rate < self.config["turnover_min"]:
            passed = False
            reasons.append(f"æ¢æ‰‹ç‡è¿‡ä½ ({stock_data.turnover_rate:.2f}% < {self.config['turnover_min']}%)")
        elif stock_data.turnover_rate > self.config["turnover_max"]:
            passed = False
            reasons.append(f"æ¢æ‰‹ç‡è¿‡é«˜ ({stock_data.turnover_rate:.2f}% > {self.config['turnover_max']}%)")

        # 3. æˆäº¤é¢
        metrics["amount"] = stock_data.amount
        if stock_data.amount < self.config["amount_min"]:
            passed = False
            reasons.append(f"æˆäº¤é¢è¿‡ä½ ({stock_data.amount/10000:.0f}ä¸‡ < {self.config['amount_min']/10000:.0f}ä¸‡)")

        # 4. æ’é™¤STè‚¡
        if self.config["exclude_st"] and ("ST" in stock_data.name or "*" in stock_data.name):
            passed = False
            reasons.append("STè‚¡/é€€å¸‚è‚¡")

        # 5. æ’é™¤æ–°è‚¡
        if self.config["exclude_new"]:
            code = self.converter.to_standard(stock_data.code)
            if code.startswith(('688', '301', '309')):  # ç§‘åˆ›æ¿ã€åˆ›ä¸šæ¿æ–°è‚¡
                passed = False
                reasons.append("æ–°è‚¡")

        return Level1Result(
            code=stock_data.code,
            passed=passed,
            reasons=reasons,
            metrics=metrics
        )


class Level2Analyzer:
    """
    Level 2: èµ„é‡‘æµå‘åˆ†æ
    
    åˆ†æå†…å®¹:
    - DDEæŒ‡æ ‡ (å¤§å•å‡€å·®)
    - ä¸»åŠ›èµ„é‡‘æµå‘
    - æ¿å—çƒ­åº¦
    - è¿æ¿é«˜åº¦
    """

    def __init__(self, config: Optional[Dict] = None):
        self.config = config or self._default_config()
        self.data_manager = get_smart_data_manager()
        self.converter = CodeConverter()

    def _default_config(self) -> Dict:
        """é»˜è®¤é…ç½®"""
        return {
            "min_fund_flow_score": 50,  # æœ€ä½èµ„é‡‘æµå¾—åˆ†
            "min_sector_heat": 40,      # æœ€ä½æ¿å—çƒ­åº¦
        }

    def analyze(self, stock_code: str) -> Level2Result:
        """
        æ‰§è¡Œ Level 2 åˆ†æ
        
        Args:
            stock_code: è‚¡ç¥¨ä»£ç 
        
        Returns:
            Level2Result: åˆ†æç»“æœ
        """
        reasons = []
        metrics = {}
        passed = True

        # 1. è·å–èµ„é‡‘æµå‘æ•°æ®
        try:
            market = self.converter.get_market(stock_code).lower()
            code = self.converter.to_standard(stock_code)

            fund_flow_data = self.data_manager.get_money_flow(code, market)

            if fund_flow_data:
                # è®¡ç®—èµ„é‡‘æµå¾—åˆ†
                main_net_in = fund_flow_data.get('ä¸»åŠ›å‡€æµå…¥', 0)
                super_large_net_in = fund_flow_data.get('è¶…å¤§å•å‡€æµå…¥', 0)
                large_net_in = fund_flow_data.get('å¤§å•å‡€æµå…¥', 0)

                # ç®€å•çš„å¾—åˆ†ç®—æ³•
                fund_flow_score = 50
                if main_net_in > 0:
                    fund_flow_score += 20
                if super_large_net_in > 0:
                    fund_flow_score += 15
                if large_net_in > 0:
                    fund_flow_score += 15

                fund_flow_score = min(100, fund_flow_score)
                metrics["fund_flow_score"] = fund_flow_score
                metrics["main_net_in"] = main_net_in
                metrics["super_large_net_in"] = super_large_net_in
                metrics["large_net_in"] = large_net_in

                if fund_flow_score < self.config["min_fund_flow_score"]:
                    passed = False
                    reasons.append(f"èµ„é‡‘æµå¾—åˆ†è¿‡ä½ ({fund_flow_score:.0f} < {self.config['min_fund_flow_score']})")
            else:
                passed = False
                reasons.append("æ— æ³•è·å–èµ„é‡‘æµæ•°æ®")

        except Exception as e:
            logger.warning(f"è·å–èµ„é‡‘æµæ•°æ®å¤±è´¥: {stock_code}, {e}")
            passed = False
            reasons.append("èµ„é‡‘æµæ•°æ®è·å–å¤±è´¥")

        # 2. æ¿å—çƒ­åº¦ (æš‚è®¾ä¸ºå›ºå®šå€¼ï¼Œåç»­å¯æ¥å…¥æ¿å—æ•°æ®)
        sector_heat = 50.0  # é»˜è®¤ä¸­ç­‰çƒ­åº¦
        metrics["sector_heat"] = sector_heat

        return Level2Result(
            code=stock_code,
            passed=passed,
            reasons=reasons,
            fund_flow_score=fund_flow_score if 'fund_flow_score' in metrics else 0,
            sector_heat=sector_heat,
            metrics=metrics
        )


class Level3RiskAssessor:
    """
    Level 3: é£é™©è¯„ä¼°
    
    è¯„ä¼°å†…å®¹:
    - è¯±å¤šé™·é˜±æ£€æµ‹ (trap_detector)
    - èµ„é‡‘æ€§è´¨åˆ†ç±» (capital_classifier)
    - ç»¼åˆé£é™©è¯„åˆ†
    """

    def __init__(self, config: Optional[Dict] = None):
        self.config = config or self._default_config()
        self.converter = CodeConverter()

        # å°è¯•åŠ è½½æ£€æµ‹å™¨
        try:
            self.trap_detector = TrapDetector()
            logger.info("âœ… [Level3] TrapDetector åŠ è½½æˆåŠŸ")
        except Exception as e:
            logger.warning(f"âš ï¸ [Level3] TrapDetector åŠ è½½å¤±è´¥: {e}")
            self.trap_detector = None

        try:
            self.capital_classifier = CapitalClassifier()
            logger.info("âœ… [Level3] CapitalClassifier åŠ è½½æˆåŠŸ")
        except Exception as e:
            logger.warning(f"âš ï¸ [Level3] CapitalClassifier åŠ è½½å¤±è´¥: {e}")
            self.capital_classifier = None

    def _default_config(self) -> Dict:
        """é»˜è®¤é…ç½®"""
        return {
            "max_trap_risk": 0.6,       # æœ€å¤§å…è®¸è¯±å¤šé£é™©
            "min_comprehensive_score": 60, # æœ€ä½ç»¼åˆå¾—åˆ†
        }

    def assess(self, stock_code: str, days: int = 90) -> Level3Result:
        """
        æ‰§è¡Œ Level 3 é£é™©è¯„ä¼°
        
        Args:
            stock_code: è‚¡ç¥¨ä»£ç 
            days: å†å²å¤©æ•°
        
        Returns:
            Level3Result: é£é™©è¯„ä¼°ç»“æœ
        """
        reasons = []
        metrics = {}
        passed = True

        # 1. è¯±å¤šé™·é˜±æ£€æµ‹
        trap_risk = 0.5  # é»˜è®¤ä¸­ç­‰é£é™©
        if self.trap_detector:
            try:
                # è¿™é‡Œéœ€è¦å®é™…è°ƒç”¨ trap_detector
                # æš‚æ—¶ä½¿ç”¨ç®€åŒ–é€»è¾‘
                trap_risk = 0.3  # å‡è®¾é£é™©è¾ƒä½
                metrics["trap_risk"] = trap_risk

                if trap_risk > self.config["max_trap_risk"]:
                    passed = False
                    reasons.append(f"è¯±å¤šé£é™©è¿‡é«˜ ({trap_risk:.2f} > {self.config['max_trap_risk']})")
            except Exception as e:
                logger.warning(f"è¯±å¤šæ£€æµ‹å¤±è´¥: {stock_code}, {e}")

        # 2. èµ„é‡‘æ€§è´¨åˆ†ç±»
        capital_type = "UNKNOWN"
        if self.capital_classifier:
            try:
                # è¿™é‡Œéœ€è¦å®é™…è°ƒç”¨ capital_classifier
                capital_type = "HOT_MONEY"  # å‡è®¾æ˜¯æ¸¸èµ„
                metrics["capital_type"] = capital_type
            except Exception as e:
                logger.warning(f"èµ„é‡‘åˆ†ç±»å¤±è´¥: {stock_code}, {e}")

        # 3. ç»¼åˆå¾—åˆ†
        comprehensive_score = 70.0  # é»˜è®¤ä¸­ç­‰å¾—åˆ†
        if trap_risk < 0.3:
            comprehensive_score += 20
        if capital_type == "INSTITUTION":
            comprehensive_score += 10

        comprehensive_score = min(100, comprehensive_score)
        metrics["comprehensive_score"] = comprehensive_score

        if comprehensive_score < self.config["min_comprehensive_score"]:
            passed = False
            reasons.append(f"ç»¼åˆå¾—åˆ†è¿‡ä½ ({comprehensive_score:.0f} < {self.config['min_comprehensive_score']})")

        # 4. é£é™©ç­‰çº§
        if trap_risk < 0.2:
            risk_level = RiskLevel.LOW
        elif trap_risk < 0.5:
            risk_level = RiskLevel.MEDIUM
        elif trap_risk < 0.7:
            risk_level = RiskLevel.HIGH
        else:
            risk_level = RiskLevel.CRITICAL

        return Level3Result(
            code=stock_code,
            passed=passed,
            risk_level=risk_level,
            trap_risk=trap_risk,
            capital_type=capital_type,
            comprehensive_score=comprehensive_score,
            reasons=reasons,
            metrics=metrics
        )


# ==================== æ¼æ–—2: ç›˜ä¸­è§¦å‘ ====================

class Level4Monitor:
    """
    Level 4: ç›˜ä¸­å®æ—¶ç›‘æ§
    
    ç›‘æ§å†…å®¹:
    - VWAPçªç ´æ£€æµ‹
    - æ‰«å•æ£€æµ‹ (æˆäº¤é‡çªç„¶æ”¾å¤§)
    - ç«ä»·çˆ†é‡æ£€æµ‹
    """

    def __init__(self, config: Optional[Dict] = None):
        self.config = config or self._default_config()
        self.monitor = IntraDayMonitor()
        self.converter = CodeConverter()
        self.data_manager = get_smart_data_manager()

        # TickçŠ¶æ€è·Ÿè¸ª
        self.tick_states: Dict[str, Dict] = {}

    def _default_config(self) -> Dict:
        """é»˜è®¤é…ç½®"""
        return {
            "vwap_threshold": 0.02,      # VWAPçªç ´é˜ˆå€¼ (2%)
            "volume_surge_ratio": 2.0,   # æ‰«å•å€æ•° (2å€)
            "auction_surge_ratio": 3.0,  # ç«ä»·çˆ†é‡å€æ•° (3å€)
            "monitor_interval": 3,       # ç›‘æ§é—´éš” (ç§’)
        }

    def calculate_vwap(self, code: str) -> float:
            """
            è®¡ç®— VWAP (æˆäº¤é‡åŠ æƒå¹³å‡ä»·)
    
            ç­–ç•¥:
            1. ä¼˜å…ˆä½¿ç”¨ QMT Tick æ•°æ®ï¼ˆå®æ—¶ã€æœ€å¿«ï¼‰
            2. QMT ä¸å¯ç”¨æ—¶ä½¿ç”¨åˆ†é’Ÿçº¿æ•°æ®
            3. æœ€åé™çº§åˆ° AkShareï¼ˆéµå®ˆé˜²å°è§„åˆ™ï¼‰
    
            Args:
                code: è‚¡ç¥¨ä»£ç 
    
            Returns:
                VWAP ä»·æ ¼
            """
            try:
                from logic.data_providers.qmt_manager import get_qmt_manager
    
                # ğŸ”¥ ä¼˜å…ˆç­–ç•¥1: ä½¿ç”¨ QMT Tick æ•°æ®ï¼ˆå®æ—¶ã€æœ€å¿«ï¼‰
                qmt_manager = get_qmt_manager()
                logger.debug(f"ğŸ” [QMT] ç®¡ç†å™¨çŠ¶æ€: available={qmt_manager.is_available()}")
    
                if qmt_manager.is_available():
                    try:
                        qmt_code = self.converter.to_qmt(code)
                        logger.info(f"ğŸ” [QMT] å°è¯•è·å– {code} ({qmt_code}) çš„ Tick æ•°æ®")
    
                        tick_data = qmt_manager.get_full_tick([qmt_code])
                        logger.debug(f"ğŸ“¦ [QMT] get_full_tick è¿”å›ç±»å‹: {type(tick_data)}")
    
                        if tick_data and qmt_code in tick_data:
                            data = tick_data[qmt_code]
                            logger.debug(f"ğŸ“Š [QMT] Tick æ•°æ®ç±»å‹: {type(data)}")
    
                            if isinstance(data, dict):
                                amount = data.get('amount', 0)
                                volume = data.get('volume', 0)
                                logger.debug(f"ğŸ’° [QMT] æˆäº¤é¢: {amount}, æˆäº¤é‡: {volume}")
    
                                if volume > 0:
                                    vwap = amount / volume
                                    logger.info(f"âœ… [QMT Tick] VWAPè®¡ç®—æˆåŠŸ: {code} = {vwap:.2f}")
                                    return vwap
                                else:
                                    logger.warning(f"âš ï¸ [QMT Tick] æˆäº¤é‡ä¸º0: {code}")
                            else:
                                logger.warning(f"âš ï¸ [QMT Tick] æ•°æ®æ ¼å¼å¼‚å¸¸: {type(data)}")
                        else:
                            logger.warning(f"âš ï¸ [QMT Tick] æœªè·å–åˆ°æ•°æ®: {code}")
    
                    except Exception as e:
                        logger.warning(f"âš ï¸ QMT Tick VWAPè®¡ç®—å¤±è´¥: {e}, å°è¯•ä½¿ç”¨åˆ†é’Ÿçº¿")
                        import traceback
                        logger.debug(traceback.format_exc())
    
                    # ğŸ”¥ ç­–ç•¥2: ä½¿ç”¨ QMT åˆ†é’Ÿçº¿æ•°æ®ï¼ˆå¤‡ç”¨ï¼‰
                    try:
                        from datetime import datetime
                        qmt_code = self.converter.to_qmt(code)
                        today = datetime.now().strftime('%Y%m%d')
    
                        logger.debug(f"ğŸ“¥ [QMT] ä¸‹è½½åˆ†é’Ÿçº¿æ•°æ®...")
                        download_success = qmt_manager.download_history_data(
                            qmt_code,
                            period='1m',
                            start_time=today,
                            end_time=today,
                            async_mode=False
                        )
    
                        if download_success:
                            data = qmt_manager.get_local_data(
                                stock_list=[qmt_code],
                                field_list=['time', 'amount', 'volume'],
                                period='1m',
                                start_time=today,
                                end_time=today
                            )
    
                            if data and qmt_code in data:
                                df = data[qmt_code]
                                logger.debug(f"ğŸ“Š [QMT] åˆ†é’Ÿçº¿æ•°æ®ç±»å‹: {type(df)}")
    
                                if hasattr(df, '__len__') and len(df) > 0:
                                    if isinstance(df, pd.DataFrame):
                                        total_amount = df['amount'].sum()
                                        total_volume = df['volume'].sum()
                                    else:
                                        import numpy as np
                                        df_array = np.array(df)
                                        if df_array.ndim == 2 and df_array.shape[1] >= 3:
                                            total_amount = np.sum(df_array[:, 1])
                                            total_volume = np.sum(df_array[:, 2])
    
                                    logger.debug(f"ğŸ’° [QMT] åˆ†é’Ÿçº¿æˆäº¤é¢: {total_amount}, æˆäº¤é‡: {total_volume}")
    
                                    if total_volume > 0:
                                        vwap = total_amount / total_volume
                                        logger.info(f"âœ… [QMT åˆ†é’Ÿçº¿] VWAPè®¡ç®—æˆåŠŸ: {code} = {vwap:.2f}")
                                        return vwap
    
                    except Exception as e:
                        logger.warning(f"âš ï¸ QMT åˆ†é’Ÿçº¿ VWAPè®¡ç®—å¤±è´¥: {e}")
    
                # ğŸ”¥ é™çº§ç­–ç•¥3: ä½¿ç”¨ AkShare æ•°æ®ï¼ˆéµå®ˆé˜²å°è§„åˆ™ï¼‰
                logger.info(f"ğŸ”„ [AkShare] é™çº§åˆ° AkShare è®¡ç®— VWAP: {code}")
    
                from logic.core.rate_limiter import safe_request
    
                def _get_akshare_vwap():
                    df = self.data_manager.get_history_kline(code, period='1min')
                    if df.empty:
                        return 0.0
    
                    total_amount = df['æˆäº¤é¢'].sum()
                    total_volume = df['æˆäº¤é‡'].sum()
    
                    if total_volume > 0:
                        return total_amount / total_volume
                    else:
                        return 0.0
    
                vwap = safe_request(_get_akshare_vwap)
    
                if vwap > 0:
                    logger.info(f"âœ… [AkShare] VWAPè®¡ç®—æˆåŠŸ: {code} = {vwap:.2f}")
                else:
                    logger.warning(f"âš ï¸ VWAPè®¡ç®—å¤±è´¥: {code}")
    
                return vwap
    
            except Exception as e:
                logger.warning(f"è®¡ç®—VWAPå¤±è´¥: {code}, {e}")
                import traceback
                logger.debug(traceback.format_exc())
                return 0.0
    def detect_vwap_breakout(self, code: str, snapshot: Dict) -> Optional[TradingSignal]:
        """
        æ£€æµ‹ VWAP çªç ´
        
        Args:
            code: è‚¡ç¥¨ä»£ç 
            snapshot: å®æ—¶å¿«ç…§
        
        Returns:
            TradingSignal æˆ– None
        """
        try:
            vwap = self.calculate_vwap(code)
            current_price = snapshot.get('price', 0)

            if vwap <= 0:
                return None

            # è®¡ç®—çªç ´å¹…åº¦
            breakout_pct = (current_price - vwap) / vwap

            if breakout_pct >= self.config["vwap_threshold"]:
                signal_id = f"VWAP_{code}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

                return TradingSignal(
                    id=signal_id,
                    stock_code=code,
                    stock_name=snapshot.get('name', code),
                    signal_type=SignalType.VWAP_BREAKOUT,
                    timestamp=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    price=current_price,
                    trigger_price=vwap,
                    signal_strength=min(1.0, breakout_pct / self.config["vwap_threshold"]),
                    risk_level=RiskLevel.MEDIUM,
                    details={
                        "vwap": vwap,
                        "breakout_pct": breakout_pct,
                        "volume": snapshot.get('volume', 0),
                        "pct_change": snapshot.get('pct_change', 0)
                    }
                )
        except Exception as e:
            logger.warning(f"VWAPçªç ´æ£€æµ‹å¤±è´¥: {code}, {e}")

        return None

    def detect_volume_surge(self, code: str, snapshot: Dict) -> Optional[TradingSignal]:
        """
        æ£€æµ‹æ‰«å• (æˆäº¤é‡çªç„¶æ”¾å¤§)
        
        Args:
            code: è‚¡ç¥¨ä»£ç 
            snapshot: å®æ—¶å¿«ç…§
        
        Returns:
            TradingSignal æˆ– None
        """
        try:
            # è·å–å†å²çŠ¶æ€
            if code not in self.tick_states:
                self.tick_states[code] = {
                    'last_volume': snapshot.get('volume', 0),
                    'last_check_time': datetime.now()
                }
                return None

            state = self.tick_states[code]
            last_volume = state['last_volume']
            current_volume = snapshot.get('volume', 0)

            # è®¡ç®—æˆäº¤é‡å¢é‡
            volume_delta = current_volume - last_volume

            # æ›´æ–°çŠ¶æ€
            state['last_volume'] = current_volume
            state['last_check_time'] = datetime.now()

            # æ£€æµ‹çˆ†é‡
            avg_volume_per_interval = 10000  # å‡è®¾å¹³å‡æ¯3ç§’1ä¸‡æ‰‹
            surge_ratio = volume_delta / avg_volume_per_interval

            if surge_ratio >= self.config["volume_surge_ratio"]:
                signal_id = f"VOL_{code}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

                return TradingSignal(
                    id=signal_id,
                    stock_code=code,
                    stock_name=snapshot.get('name', code),
                    signal_type=SignalType.VOLUME_SURGE,
                    timestamp=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    price=snapshot.get('price', 0),
                    trigger_price=snapshot.get('price', 0),
                    signal_strength=min(1.0, surge_ratio / self.config["volume_surge_ratio"]),
                    risk_level=RiskLevel.MEDIUM,
                    details={
                        "volume_delta": volume_delta,
                        "surge_ratio": surge_ratio,
                        "current_volume": current_volume,
                        "pct_change": snapshot.get('pct_change', 0)
                    }
                )
        except Exception as e:
            logger.warning(f"æ‰«å•æ£€æµ‹å¤±è´¥: {code}, {e}")

        return None

    def monitor_stock(self, code: str) -> List[TradingSignal]:
        """
        ç›‘æ§å•åªè‚¡ç¥¨
        
        Args:
            code: è‚¡ç¥¨ä»£ç 
        
        Returns:
            ä¿¡å·åˆ—è¡¨
        """
        signals = []

        try:
            # è·å–å®æ—¶å¿«ç…§
            snapshot = self.monitor.get_intraday_snapshot(code)

            if not snapshot.get('success'):
                return signals

            # æ£€æµ‹å„ç§ä¿¡å·
            vwap_signal = self.detect_vwap_breakout(code, snapshot)
            if vwap_signal:
                signals.append(vwap_signal)

            volume_signal = self.detect_volume_surge(code, snapshot)
            if volume_signal:
                signals.append(volume_signal)

        except Exception as e:
            logger.error(f"ç›‘æ§è‚¡ç¥¨å¤±è´¥: {code}, {e}")

        return signals


# ==================== è§‚å¯Ÿæ± ç®¡ç† ====================

class WatchlistManager:
    """è§‚å¯Ÿæ± ç®¡ç†å™¨"""

    def __init__(self, config_path: str = "config/watchlist_pool.json"):
        self.config_path = Path(config_path)
        self.watchlist: Dict[str, WatchlistItem] = {}
        self._load()

    def _load(self):
        """åŠ è½½è§‚å¯Ÿæ± """
        if self.config_path.exists():
            try:
                with open(self.config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)

                for item_data in data.get('stocks', []):
                    item = WatchlistItem(**item_data)
                    self.watchlist[item.code] = item

                logger.info(f"âœ… åŠ è½½è§‚å¯Ÿæ± : {len(self.watchlist)} åªè‚¡ç¥¨")
            except Exception as e:
                logger.error(f"âŒ åŠ è½½è§‚å¯Ÿæ± å¤±è´¥: {e}")

    def _save(self):
        """ä¿å­˜è§‚å¯Ÿæ± """
        try:
            data = {
                'stocks': [
                    {
                        'code': item.code,
                        'name': item.name,
                        'reason': item.reason,
                        'added_at': item.added_at,
                        'last_updated': item.last_updated,
                        'level1_result': item.level1_result.__dict__ if item.level1_result else None,
                        'level2_result': item.level2_result.__dict__ if item.level2_result else None,
                        'level3_result': item.level3_result.__dict__ if item.level3_result else None,
                    }
                    for item in self.watchlist.values()
                ],
                'updated_at': datetime.now().isoformat()
            }

            self.config_path.parent.mkdir(parents=True, exist_ok=True)
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)

            logger.info(f"âœ… ä¿å­˜è§‚å¯Ÿæ± : {len(self.watchlist)} åªè‚¡ç¥¨")
        except Exception as e:
            logger.error(f"âŒ ä¿å­˜è§‚å¯Ÿæ± å¤±è´¥: {e}")

    def add(self, code: str, name: str, reason: str):
        """æ·»åŠ è‚¡ç¥¨åˆ°è§‚å¯Ÿæ± """
        if code in self.watchlist:
            logger.warning(f"è‚¡ç¥¨å·²å­˜åœ¨: {code}")
            return

        item = WatchlistItem(
            code=code,
            name=name,
            reason=reason,
            added_at=datetime.now().isoformat(),
            last_updated=datetime.now().isoformat()
        )

        self.watchlist[code] = item
        self._save()
        logger.info(f"âœ… æ·»åŠ è‚¡ç¥¨åˆ°è§‚å¯Ÿæ± : {code} {name}")

    def remove(self, code: str):
        """ä»è§‚å¯Ÿæ± ç§»é™¤è‚¡ç¥¨"""
        if code in self.watchlist:
            del self.watchlist[code]
            self._save()
            logger.info(f"âœ… ä»è§‚å¯Ÿæ± ç§»é™¤è‚¡ç¥¨: {code}")

    def get_all(self) -> List[WatchlistItem]:
        """è·å–æ‰€æœ‰è§‚å¯Ÿæ± è‚¡ç¥¨"""
        return list(self.watchlist.values())

    def get_codes(self) -> List[str]:
        """è·å–æ‰€æœ‰è‚¡ç¥¨ä»£ç """
        return list(self.watchlist.keys())

    def update_result(self, code: str, level: int, result: Any):
        """æ›´æ–°ç­›é€‰ç»“æœ"""
        if code not in self.watchlist:
            return

        item = self.watchlist[code]
        if level == 1:
            item.level1_result = result
        elif level == 2:
            item.level2_result = result
        elif level == 3:
            item.level3_result = result

        item.last_updated = datetime.now().isoformat()
        self._save()


# ==================== ä¸»æ‰«æå™¨ ====================

class TripleFunnelScanner:
    """ä¸‰æ¼æ–—æ‰«æå™¨ä¸»ç±»"""

    def __init__(self, config_path: str = "config/watchlist_pool.json"):
        self.watchlist_manager = WatchlistManager(config_path)
        self.level1_filter = Level1Filter()
        self.level2_analyzer = Level2Analyzer()
        self.level3_assessor = Level3RiskAssessor()
        self.level4_monitor = Level4Monitor()
        self.converter = CodeConverter()
        self.data_manager = get_smart_data_manager()

        logger.info("âœ… ä¸‰æ¼æ–—æ‰«æå™¨åˆå§‹åŒ–å®Œæˆ")

    def run_post_market_scan(self, max_stocks: int = 100) -> List[str]:
        """
        è¿è¡Œç›˜åæ‰«æ (Level 1-3)
        
        Args:
            max_stocks: æœ€å¤§æ‰«æè‚¡ç¥¨æ•° (é¿å…å…¨å¸‚åœºæ‰«æå¤ªæ…¢)
        
        Returns:
            é€šè¿‡ç­›é€‰çš„è‚¡ç¥¨ä»£ç åˆ—è¡¨
        """
        logger.info(f"ğŸš€ å¼€å§‹ç›˜åæ‰«æ (Level 1-3)")
        passed_stocks = []

        # è·å–è§‚å¯Ÿæ± è‚¡ç¥¨
        watchlist = self.watchlist_manager.get_all()
        stock_codes = [item.code for item in watchlist]

        if not stock_codes:
            logger.warning("âš ï¸ è§‚å¯Ÿæ± ä¸ºç©ºï¼Œè¯·å…ˆæ·»åŠ è‚¡ç¥¨")
            return passed_stocks

        # é™åˆ¶æ‰«ææ•°é‡
        stock_codes = stock_codes[:max_stocks]
        logger.info(f"ğŸ“‹ æ‰«æ {len(stock_codes)} åªè‚¡ç¥¨")

        # è·å–å®æ—¶è¡Œæƒ…
        try:
            df_quotes = self.data_manager.get_realtime_quotes(stock_codes)

            if df_quotes.empty:
                logger.error("âŒ è·å–å®æ—¶è¡Œæƒ…å¤±è´¥")
                return passed_stocks

            # é€åªè‚¡ç¥¨ç­›é€‰
            for _, row in df_quotes.iterrows():
                code = row['ä»£ç ']
                name = row['åç§°']

                # Level 1: åŸºç¡€è¿‡æ»¤
                stock_info = StockBasicInfo(
                    code=code,
                    name=name,
                    price=float(row['æœ€æ–°ä»·']),
                    pct_change=float(row['æ¶¨è·Œå¹…']),
                    volume=int(row['æˆäº¤é‡']),
                    amount=float(row['æˆäº¤é¢']),
                    turnover_rate=float(row.get('æ¢æ‰‹ç‡', 0)),
                    high=float(row['æœ€é«˜']),
                    low=float(row['æœ€ä½']),
                    open=float(row['ä»Šå¼€'])
                )

                level1_result = self.level1_filter.filter(stock_info)
                self.watchlist_manager.update_result(code, 1, level1_result)

                if not level1_result.passed:
                    logger.debug(f"âŒ [Level1] {code} {name}: {', '.join(level1_result.reasons)}")
                    continue

                logger.info(f"âœ… [Level1] {code} {name} é€šè¿‡")

                # Level 2: èµ„é‡‘æµå‘åˆ†æ
                level2_result = self.level2_analyzer.analyze(code)
                self.watchlist_manager.update_result(code, 2, level2_result)

                if not level2_result.passed:
                    logger.debug(f"âŒ [Level2] {code} {name}: {', '.join(level2_result.reasons)}")
                    continue

                logger.info(f"âœ… [Level2] {code} {name} é€šè¿‡ (èµ„é‡‘æµå¾—åˆ†: {level2_result.fund_flow_score:.0f})")

                # Level 3: é£é™©è¯„ä¼°
                level3_result = self.level3_assessor.assess(code)
                self.watchlist_manager.update_result(code, 3, level3_result)

                if not level3_result.passed:
                    logger.debug(f"âŒ [Level3] {code} {name}: {', '.join(level3_result.reasons)}")
                    continue

                logger.info(f"âœ… [Level3] {code} {name} é€šè¿‡ (ç»¼åˆå¾—åˆ†: {level3_result.comprehensive_score:.0f})")

                # é€šè¿‡æ‰€æœ‰ç­›é€‰
                passed_stocks.append(code)

        except Exception as e:
            logger.error(f"âŒ ç›˜åæ‰«æå¤±è´¥: {e}")

        logger.info(f"âœ… ç›˜åæ‰«æå®Œæˆ: {len(passed_stocks)} åªè‚¡ç¥¨é€šè¿‡")
        return passed_stocks

    def run_intraday_monitor(self, watchlist: Optional[List[str]] = None,
                            interval: int = 3) -> List[TradingSignal]:
        """
        è¿è¡Œç›˜ä¸­ç›‘æ§ (Level 4)
        
        Args:
            watchlist: ç›‘æ§è‚¡ç¥¨åˆ—è¡¨ (Noneåˆ™ä½¿ç”¨è§‚å¯Ÿæ± )
            interval: ç›‘æ§é—´éš” (ç§’)
        
        Returns:
            è§¦å‘çš„ä¿¡å·åˆ—è¡¨
        """
        logger.info(f"ğŸš€ å¼€å§‹ç›˜ä¸­ç›‘æ§ (Level 4)")

        if watchlist is None:
            watchlist = self.watchlist_manager.get_codes()

        if not watchlist:
            logger.warning("âš ï¸ ç›‘æ§åˆ—è¡¨ä¸ºç©º")
            return []

        all_signals = []

        # é€åªè‚¡ç¥¨ç›‘æ§
        for code in watchlist:
            signals = self.level4_monitor.monitor_stock(code)
            all_signals.extend(signals)

            if signals:
                logger.info(f"âš¡ {code} è§¦å‘ {len(signals)} ä¸ªä¿¡å·")
                for signal in signals:
                    logger.info(f"   - {signal.signal_type.value}: {signal.details}")

        return all_signals


# ==================== ä½¿ç”¨ç¤ºä¾‹ ====================

if __name__ == "__main__":
    print("=" * 80)
    print("ğŸš€ ä¸‰æ¼æ–—æ‰«æç³»ç»Ÿ - æ¼”ç¤º")
    print("=" * 80)

    # åˆ›å»ºæ‰«æå™¨
    scanner = TripleFunnelScanner()

    # 1. æ·»åŠ æµ‹è¯•è‚¡ç¥¨åˆ°è§‚å¯Ÿæ± 
    print("\nğŸ“ æ·»åŠ æµ‹è¯•è‚¡ç¥¨åˆ°è§‚å¯Ÿæ± ...")
    scanner.watchlist_manager.add("000001", "å¹³å®‰é“¶è¡Œ", "æµ‹è¯•ç”¨")
    scanner.watchlist_manager.add("600519", "è´µå·èŒ…å°", "æµ‹è¯•ç”¨")

    # 2. è¿è¡Œç›˜åæ‰«æ
    print("\nğŸ” è¿è¡Œç›˜åæ‰«æ...")
    passed = scanner.run_post_market_scan(max_stocks=10)
    print(f"âœ… é€šè¿‡ç­›é€‰: {passed}")

    # 3. æŸ¥çœ‹è§‚å¯Ÿæ± çŠ¶æ€
    print("\nğŸ“Š è§‚å¯Ÿæ± çŠ¶æ€:")
    for item in scanner.watchlist_manager.get_all():
        print(f"  {item.code} {item.name}")
        if item.level1_result:
            print(f"    Level1: {'âœ…' if item.level1_result.passed else 'âŒ'}")
        if item.level2_result:
            print(f"    Level2: {'âœ…' if item.level2_result.passed else 'âŒ'} (å¾—åˆ†: {item.level2_result.fund_flow_score:.0f})")
        if item.level3_result:
            print(f"    Level3: {'âœ…' if item.level3_result.passed else 'âŒ'} (å¾—åˆ†: {item.level3_result.comprehensive_score:.0f})")

    # 4. è¿è¡Œç›˜ä¸­ç›‘æ§ (æµ‹è¯•)
    print("\nâš¡ è¿è¡Œç›˜ä¸­ç›‘æ§...")
    signals = scanner.run_intraday_monitor()
    print(f"âœ… è§¦å‘ä¿¡å·: {len(signals)}")

    print("\n" + "=" * 80)
