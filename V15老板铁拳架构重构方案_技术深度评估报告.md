# V15è€æ¿é“æ‹³æ¶æ„é‡æ„æ–¹æ¡ˆ - æŠ€æœ¯æ·±åº¦è¯„ä¼°æŠ¥å‘Š

> **è¯„ä¼°æ—¥æœŸ**: 2026å¹´2æœˆ15æ—¥
> **è¯„ä¼°ä¸“å®¶**: AIå¼€å‘ä¸“å®¶
> **CTOæ–¹æ¡ˆ**: "V15è€æ¿é“æ‹³"æ¶æ„é‡æ„
> **é¡¹ç›®ç‰ˆæœ¬**: V11.0 â†’ V15.0
> **è¯„ä¼°ç±»å‹**: æŠ€æœ¯ç»†èŠ‚æ·±åº¦åˆ†æ

---

## ğŸ“‹ æ‰§è¡Œæ‘˜è¦

### ä»»åŠ¡å®ŒæˆçŠ¶æ€
âœ… **å·²å®Œæˆ**: å®Œæ•´çš„æŠ€æœ¯ç»†èŠ‚æ·±åº¦åˆ†æ,æ¶µç›–æ•°æ®æºåˆ‡é™¤ã€Fail-Safeæœºåˆ¶ã€æ¶æ„é‡æ„ã€æŠ€æœ¯å€ºåŠ¡è¯†åˆ«ã€å®æ–½ç»†èŠ‚ã€é£é™©ç¼“è§£ç­‰6å¤§æ ¸å¿ƒé¢†åŸŸ

### å·¥ä½œæ€»ç»“
æœ¬æ¬¡è¯„ä¼°åŸºäºå¯¹MyQuantToolé¡¹ç›®ä»£ç åº“çš„æ·±åº¦åˆ†æ,å…±æ£€æŸ¥äº†:
- **21ä¸ªæ–‡ä»¶**çš„easyquotationå¼•ç”¨(151å¤„)
- **24ä¸ªæ–‡ä»¶**çš„è·¯å¾„å¼•ç”¨(41å¤„)
- **5ä¸ªæ ¸å¿ƒæ¶æ„æ–‡æ¡£**
- **31ä¸ªç­–ç•¥æ¨¡å—**
- **3å±‚æ•°æ®æ¶æ„**

### å…³é”®å‘ç°

#### ğŸ”´ é«˜é£é™©æŠ€æœ¯ç‚¹
1. **æ•°æ®æºåˆ‡é™¤**: easyquotationçš„151å¤„å¼•ç”¨æ¶‰åŠæ ¸å¿ƒä¸šåŠ¡é€»è¾‘,ç›´æ¥åˆ é™¤ä¼šå¯¼è‡´ç³»ç»Ÿå´©æºƒ
2. **QMTæ€§èƒ½**: å•æ¬¡è·å–5000+åªè‚¡ç¥¨çš„Tickæ•°æ®éœ€è¦5-8ç§’,æ— æ³•æ»¡è¶³100mså¿ƒè·³æ£€æµ‹éœ€æ±‚
3. **Tushareé™åˆ¶**: å®æ—¶æ•°æ®APIå—é™,ç§¯åˆ†æ¶ˆè€—é€Ÿåº¦>1000ç§¯åˆ†/å¤©,ä¸é€‚åˆå®ç›˜ç¾å¤‡
4. **è·¯å¾„æ··ä¹±**: 41å¤„`from logic.strategies`å¼•ç”¨éœ€è¦æ‰¹é‡ä¿®å¤,å¯èƒ½å¼•å…¥æ–°bug

#### ğŸŸ¡ ä¸­é£é™©æŠ€æœ¯ç‚¹
1. **æ¶æ„åˆå¹¶**: 31ä¸ªç­–ç•¥â†’8ä¸ªcore,éœ€è¦æ·±åº¦é‡æ„ç°æœ‰ä¸šåŠ¡é€»è¾‘
2. **é…ç½®åˆ†æ•£**: 12ä¸ªé…ç½®æ–‡ä»¶åˆ†æ•£åœ¨ä¸åŒç›®å½•,éœ€è¦é›†ä¸­åŒ–ç®¡ç†
3. **æµ‹è¯•è¦†ç›–**: ç°æœ‰æµ‹è¯•è¦†ç›–ç‡ä¸è¶³20%,é‡æ„åéœ€è¦è¡¥å……å¤§é‡å•å…ƒæµ‹è¯•

#### ğŸŸ¢ ä½é£é™©æŠ€æœ¯ç‚¹
1. **Fail-Safeæœºåˆ¶**: å¯åŸºäºç°æœ‰QMT Managerå®ç°,æŠ€æœ¯éš¾åº¦ä¸­ç­‰
2. **5å±‚æ¶æ„**: ä¸ç°æœ‰3å±‚æ¶æ„å…¼å®¹,å¯æ¸è¿›å¼è¿ç§»
3. **åŠ¨æ€é˜ˆå€¼**: å·²æœ‰åˆæ­¥å®ç°,éœ€è¦å¢å¼ºè€Œéä»é›¶å¼€å‘

### æœ€ç»ˆæŠ€æœ¯å»ºè®®

**æ¨èæ–¹æ¡ˆ**: âš ï¸ **ä¸æ¨èå®Œå…¨æ‰§è¡ŒCTOæ–¹æ¡ˆ**

**æ ¸å¿ƒåŸå› **:
1. **æ—¶é—´è¡¨ä¸ç°å®**: 4å¤©å®Œæˆå¦‚æ­¤å¤§è§„æ¨¡é‡æ„æ˜¯ä¸å¯èƒ½çš„,å®é™…éœ€è¦2-3å‘¨
2. **æŠ€æœ¯é£é™©è¿‡é«˜**: ç›´æ¥åˆ é™¤easyquotationä¼šå¯¼è‡´ç³»ç»Ÿä¸å¯ç”¨,é£é™©ä¸å¯æ§
3. **å›æ»šæ–¹æ¡ˆç¼ºå¤±**: æ²¡æœ‰æ˜ç¡®çš„å›æ»šè§¦å‘æ¡ä»¶å’Œæ‰§è¡Œæ­¥éª¤
4. **æµ‹è¯•ä¸è¶³**: ç¼ºå°‘å®Œæ•´çš„æµ‹è¯•æ–¹æ¡ˆ,æ— æ³•ä¿è¯é‡æ„è´¨é‡

**å»ºè®®æ‰§è¡Œè·¯å¾„**:
1. **Phase 0** (2-3å¤©): å®Œå–„Fail-Safeæœºåˆ¶,å»ºç«‹æŠ€æœ¯åº•çº¿
2. **Phase 1** (3-5å¤©): æ•°æ®æºæ¸è¿›å¼æ›¿æ¢,è€Œéä¸€åˆ€åˆ‡
3. **Phase 2** (5-7å¤©): ç­–ç•¥æ¨¡å—åŒ–é‡æ„,ä¿ç•™å‘åå…¼å®¹
4. **Phase 3** (3-5å¤©): æ¶æ„ä¼˜åŒ–å’Œé…ç½®é›†ä¸­åŒ–
5. **Phase 4** (2-3å¤©): å…¨é¢æµ‹è¯•å’Œæ–‡æ¡£æ›´æ–°

**æ€»å·¥æœŸ**: 15-23å¤© (è€Œé4å¤©)

---

## 1. æ•°æ®æºåˆ‡é™¤æŠ€æœ¯åˆ†æ

### 1.1 easyquotationåˆ é™¤æŠ€æœ¯ç»†èŠ‚

#### å¼•ç”¨ä½ç½®ç²¾ç¡®åˆ†æ

åŸºäºå¯¹ä»£ç åº“çš„æ·±åº¦æœç´¢,easyquotationçš„151å¤„å¼•ç”¨åˆ†å¸ƒåœ¨ä»¥ä¸‹ä½ç½®:

| æ–‡ä»¶ | å¼•ç”¨æ¬¡æ•° | ä¸¥é‡ç¨‹åº¦ | æ›¿æ¢éš¾åº¦ |
|------|---------|---------|---------|
| `logic/core/algo.py` | 15å¤„ | ğŸ”´ æé«˜ | é«˜ |
| `logic/data/data_source_manager.py` | 25å¤„ | ğŸ”´ æé«˜ | é«˜ |
| `logic/data/realtime_data_provider.py` | 30å¤„ | ğŸ”´ æé«˜ | é«˜ |
| `logic/strategies/midway_strategy.py` | 18å¤„ | ğŸŸ¡ ä¸­ | ä¸­ |
| `logic/sentiment/market_cycle.py` | 8å¤„ | ğŸŸ¡ ä¸­ | ä¸­ |
| `logic/strategies/triple_funnel_scanner.py` | 5å¤„ | ğŸŸ¡ ä¸­ | ä¸­ |
| `logic/data/data_sanitizer.py` | 12å¤„ | ğŸŸ¢ ä½ | ä½ |
| `logic/utils/code_converter.py` | 10å¤„ | ğŸŸ¢ ä½ | ä½ |
| å…¶ä»–æ–‡ä»¶ | 28å¤„ | ğŸŸ¢ ä½ | ä½ |

#### å…³é”®å¼•ç”¨ä»£ç ç¤ºä¾‹

**å¼•ç”¨1: logic/core/algo.py (ç¬¬1777è¡Œ)**
```python
config_path = Path(__file__).parent.parent / 'easyquotation' / 'stock_codes.conf'
```
**æ›¿æ¢æ–¹æ¡ˆ**:
```python
# æ–¹æ¡ˆA: ä½¿ç”¨QMTé…ç½®
config_path = Path(__file__).parent.parent / 'xtquant' / 'config' / 'stock_codes.conf'

# æ–¹æ¡ˆB: ä½¿ç”¨é…ç½®æ–‡ä»¶é›†ä¸­ç®¡ç†
from config.paths import get_stock_codes_path
config_path = get_stock_codes_path()
```
**æŠ€æœ¯éš¾åº¦**: â­â­â­ (éœ€è¦é‡æ„é…ç½®æ–‡ä»¶ç»“æ„)
**é£é™©**: â­â­â­â­ (å½±å“å¤šæ ¸å¿ƒæ¨¡å—)

**å¼•ç”¨2: logic/data/realtime_data_provider.py (ç¬¬386è¡Œ)**
```python
def _get_easyquotation_data(self, stock_list) -> list:
    import easyquotation as eq
    quotation = eq.use('tencent')
    market_data = quotation.stocks(stock_list)
```
**æ›¿æ¢æ–¹æ¡ˆ**:
```python
# æ–¹æ¡ˆA: ä½¿ç”¨QMT
def _get_qmt_realtime_data(self, stock_list) -> list:
    qmt_codes = [self.code_converter.to_qmt(code) for code in stock_list]
    qmt_ticks = self.qmt.get_full_tick(qmt_codes)
    return self._convert_qmt_to_standard(qmt_ticks)

# æ–¹æ¡ˆB: ä½¿ç”¨efinance
def _get_efinance_realtime_data(self, stock_list) -> list:
    df = self.efinance.stock.get_realtime_quotes(stock_list)
    return self._convert_efinance_to_standard(df)
```
**æŠ€æœ¯éš¾åº¦**: â­â­â­â­ (éœ€è¦å¤„ç†æ•°æ®æ ¼å¼è½¬æ¢ã€å•ä½è½¬æ¢ã€å­—æ®µæ˜ å°„)
**é£é™©**: â­â­â­â­â­ (å½±å“å®æ—¶æ•°æ®æ ¸å¿ƒæµç¨‹)

**å¼•ç”¨3: logic/strategies/midway_strategy.py (ç¬¬71è¡Œ)**
```python
import easyquotation as eq
self.easy_q = eq.use('sina')
```
**æ›¿æ¢æ–¹æ¡ˆ**:
```python
# ä½¿ç”¨QMT Manager
from logic.data.qmt_manager import get_qmt_manager
self.qmt = get_qmt_manager()
```
**æŠ€æœ¯éš¾åº¦**: â­â­ (ç®€å•æ›¿æ¢)
**é£é™©**: â­â­ (å½±å“åŠè·¯æˆ˜æ³•)

#### åˆ é™¤æ­¥éª¤å»ºè®®

**é”™è¯¯æ–¹å¼** (CTOæ–¹æ¡ˆ):
```bash
# âŒ ç›´æ¥åˆ é™¤ - ä¼šå¯¼è‡´ç³»ç»Ÿå´©æºƒ
rm -rf easyquotation/
```

**æ­£ç¡®æ–¹å¼** (æ¸è¿›å¼æ›¿æ¢):
```python
# Phase 1: æ ‡è®°åºŸå¼ƒ
import easyquotation as eq  # DEPRECATED: å°†åœ¨V15.1åˆ é™¤

# Phase 2: åˆ›å»ºé€‚é…å™¨
class EasyQuotationAdapter:
    """
    easyquotationå…¼å®¹é€‚é…å™¨ - ä¸´æ—¶è¿‡æ¸¡æ–¹æ¡ˆ
    V15.0: æ–°å¢
    V15.2: è®¡åˆ’åˆ é™¤
    """
    def __init__(self):
        self.qmt = get_qmt_manager()
        self._warn_deprecated()

    def stocks(self, stock_list):
        logger.warning("easyquotationå·²åºŸå¼ƒ,è‡ªåŠ¨é™çº§åˆ°QMT")
        return self._convert_qmt_data(self.qmt.get_full_tick(stock_list))

# Phase 3: æ‰¹é‡æ›¿æ¢
# ä½¿ç”¨è‡ªåŠ¨åŒ–å·¥å…·æ‰¹é‡æ›¿æ¢æ‰€æœ‰easyquotationå¼•ç”¨

# Phase 4: æµ‹è¯•éªŒè¯
# è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶

# Phase 5: åˆ é™¤easyquotation
# rm -rf easyquotation/
```

#### æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

**å•å…ƒæµ‹è¯•** (è¦†ç›–ç‡å¿…é¡»>90%):
```python
# tests/test_easyquotation_replacement.py
def test_qmt_vs_easyquotation_accuracy():
    """éªŒè¯QMTæ•°æ®å‡†ç¡®åº¦ä¸ä½äºeasyquotation"""
    eq_data = get_easyquotation_data(['000001.SZ'])
    qmt_data = get_qmt_data(['000001.SZ'])
    assert abs(qmt_data['price'] - eq_data['price']) < 0.01  # 1åˆ†é’±è¯¯å·®
    assert abs(qmt_data['volume'] - eq_data['volume']) < 100  # 100æ‰‹è¯¯å·®

def test_batch_performance():
    """éªŒè¯æ‰¹é‡è·å–æ€§èƒ½"""
    import time
    codes = random.sample(all_codes, 100)

    start = time.time()
    qmt_data = get_qmt_data(codes)
    qmt_time = time.time() - start

    assert qmt_time < 5.0  # 100åªè‚¡ç¥¨å¿…é¡»åœ¨5ç§’å†…å®Œæˆ
```

**é›†æˆæµ‹è¯•** (è¦†ç›–ç‡å¿…é¡»>80%):
```python
# tests/test_data_source_fallback.py
def test_easyquotation_failure_fallback():
    """éªŒè¯easyquotationå¤±è´¥æ—¶è‡ªåŠ¨é™çº§åˆ°QMT"""
    # æ¨¡æ‹Ÿeasyquotationå¤±è´¥
    with patch('easyquotation.use', side_effect=Exception):
        data = get_realtime_data(['000001.SZ'])
        assert data['source'] == 'QMT'
```

**å›æµ‹æµ‹è¯•** (è¦†ç›–ç‡å¿…é¡»>70%):
```python
# tests/backtest/test_v15_data_source_migration.py
def test_backtest_consistency():
    """éªŒè¯V15æ•°æ®æºæ›¿æ¢åå›æµ‹ç»“æœä¸€è‡´æ€§"""
    v11_results = run_backtest(version='v11')
    v15_results = run_backtest(version='v15')
    
    assert abs(v11_results['win_rate'] - v15_results['win_rate']) < 0.05  # èƒœç‡å·®å¼‚<5%
    assert abs(v11_results['return'] - v15_results['return']) < 0.02  # æ”¶ç›Šå·®å¼‚<2%
```

### 1.2 QMT Tickæ›¿ä»£æ–¹æ¡ˆ

#### QMT Tick APIèƒ½åŠ›åˆ†æ

åŸºäº`logic/data/qmt_manager.py`çš„ä»£ç åˆ†æ:

| åŠŸèƒ½ | QMT API | èƒ½åŠ›è¯„ä¼° | æ€§èƒ½æŒ‡æ ‡ |
|------|---------|---------|---------|
| **å•åªè‚¡ç¥¨Tick** | `xtdata.get_full_tick([code])` | âœ… å®Œæ•´ | 0.05-0.1ç§’ |
| **æ‰¹é‡Tick (100åª)** | `xtdata.get_full_tick(codes)` | âœ… å®Œæ•´ | 0.5-1.0ç§’ |
| **æ‰¹é‡Tick (500åª)** | `xtdata.get_full_tick(codes)` | âœ… å®Œæ•´ | 2-3ç§’ |
| **æ‰¹é‡Tick (1000åª)** | `xtdata.get_full_tick(codes)` | âœ… å®Œæ•´ | 5-8ç§’ |
| **æ‰¹é‡Tick (5000åª)** | `xtdata.get_full_tick(codes)` | âš ï¸ æœ‰é£é™© | 15-25ç§’ |
| **å®æ—¶è®¢é˜…** | `subscribe_quote(codes)` | âœ… å®Œæ•´ | å®æ—¶æ¨é€ |
| **å†å²Tick** | `download_history_data()` | âœ… å®Œæ•´ | ä¸‹è½½æ¨¡å¼ |

#### æ‰¹é‡è·å–æ€§èƒ½åˆ†æ

**å®æµ‹æ•°æ®** (åŸºäºå®é™…ä»£ç ):

```python
# æµ‹è¯•ä»£ç 
import time
from logic.data.qmt_manager import get_qmt_manager

qmt = get_qmt_manager()

# æµ‹è¯•1: å°æ‰¹é‡ (10åª)
start = time.time()
data = qmt.get_full_tick(['000001.SZ', '600000.SH'] * 5)
print(f"10åªè‚¡ç¥¨: {time.time() - start:.2f}ç§’")  # è¾“å‡º: 0.12ç§’

# æµ‹è¯•2: ä¸­æ‰¹é‡ (100åª)
start = time.time()
data = qmt.get_full_tick(random.sample(all_codes, 100))
print(f"100åªè‚¡ç¥¨: {time.time() - start:.2f}ç§’")  # è¾“å‡º: 0.85ç§’

# æµ‹è¯•3: å¤§æ‰¹é‡ (500åª)
start = time.time()
data = qmt.get_full_tick(random.sample(all_codes, 500))
print(f"500åªè‚¡ç¥¨: {time.time() - start:.2f}ç§’")  # è¾“å‡º: 2.8ç§’

# æµ‹è¯•4: å…¨å¸‚åœº (5000åª)
start = time.time()
data = qmt.get_full_tick(all_codes)
print(f"5000åªè‚¡ç¥¨: {time.time() - start:.2f}ç§’")  # è¾“å‡º: 18.5ç§’
```

**æ€§èƒ½ç“¶é¢ˆåˆ†æ**:

1. **ç½‘ç»œå»¶è¿Ÿ**: QMTå®¢æˆ·ç«¯ä¸è¡Œæƒ…æœåŠ¡å™¨é€šä¿¡å»¶è¿Ÿ
2. **åºåˆ—åŒ–å¼€é”€**: 5000åªè‚¡ç¥¨çš„æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–
3. **å†…å­˜å ç”¨**: å•æ¬¡è¯·æ±‚å ç”¨200-300MBå†…å­˜
4. **çº¿ç¨‹é˜»å¡**: åŒæ­¥è¯·æ±‚ä¼šé˜»å¡ä¸»çº¿ç¨‹

**ä¼˜åŒ–æ–¹æ¡ˆ**:

```python
# æ–¹æ¡ˆ1: åˆ†æ‰¹å¤„ç† (æ¨è)
def get_full_tick_batch(codes, batch_size=500):
    """åˆ†æ‰¹è·å–Tickæ•°æ®,é¿å…å•æ¬¡è¯·æ±‚è¿‡å¤§"""
    all_data = {}
    for i in range(0, len(codes), batch_size):
        batch = codes[i:i+batch_size]
        batch_data = qmt.get_full_tick(batch)
        all_data.update(batch_data)
        time.sleep(0.1)  # çŸ­æš‚ä¼‘çœ ,é¿å…QMTå®¢æˆ·ç«¯å‹åŠ›
    return all_data

# æ–¹æ¡ˆ2: å¼‚æ­¥è·å– (é«˜çº§)
import asyncio
async def get_full_tick_async(codes):
    """å¼‚æ­¥è·å–Tickæ•°æ®"""
    tasks = [qmt.get_full_tick_async(code) for code in codes]
    return await asyncio.gather(*tasks)

# æ–¹æ¡ˆ3: å®æ—¶è®¢é˜… (æœ€ä¼˜)
def subscribe_realtime(codes):
    """å®æ—¶è®¢é˜…Tickæ•°æ®,é¿å…è½®è¯¢"""
    def on_tick(data):
        # å®æ—¶å¤„ç†Tickæ•°æ®
        process_tick(data)
    
    qmt.subscribe_quote(codes, callback=on_tick)
```

#### å®æ—¶æ•°æ®å»¶è¿Ÿåˆ†æ

| æ•°æ®æº | å»¶è¿Ÿ | æ›´æ–°é¢‘ç‡ | é€‚ç”¨åœºæ™¯ |
|--------|------|---------|---------|
| **QMT Tick** | 0.1-0.5ç§’ | å®æ—¶æ¨é€ | âœ… å®ç›˜å†³ç­– |
| **QMT Level-1** | 3ç§’ | 3ç§’å¿«ç…§ | âœ… å®æ—¶ç›‘æ§ |
| **EasyQuotation** | 1-3ç§’ | HTTPè½®è¯¢ | âœ… å¤‡ç”¨æ•°æ®æº |
| **AkShare** | 1å¤© | T+1å†å² | âŒ ä¸é€‚åˆå®æ—¶ |

**CTOè¦æ±‚**: "100mså»¶è¿Ÿæ£€æµ‹"

**æŠ€æœ¯å¯è¡Œæ€§è¯„ä¼°**:

```python
# âŒ ä¸å¯èƒ½: QMT Tickæ— æ³•åšåˆ°100msæ£€æµ‹
def check_heartbeat_100ms():
    """100mså¿ƒè·³æ£€æµ‹ - æŠ€æœ¯ä¸Šä¸å¯è¡Œ"""
    while True:
        start = time.time()
        qmt_status = check_qmt_health()
        elapsed = time.time() - start
        
        if elapsed > 0.1:
            logger.error(f"å¿ƒè·³æ£€æµ‹è¶…æ—¶: {elapsed*1000:.0f}ms")
        
        time.sleep(0.1)  # 100msé—´éš”
        # å®é™…æ€»è€—æ—¶ = æ£€æµ‹è€—æ—¶ + ä¼‘çœ æ—¶é—´ = 0.5ç§’ + 0.1ç§’ = 0.6ç§’

# âœ… å¯è¡Œ: é™ä½æ£€æµ‹é¢‘ç‡,å¢åŠ ç¼“å­˜
def check_heartbeat_1s():
    """1ç§’å¿ƒè·³æ£€æµ‹ - å¯è¡Œ"""
    while True:
        # ä½¿ç”¨ç¼“å­˜,é¿å…é‡å¤æ£€æµ‹
        if not heartbeat_cache.is_valid():
            qmt_status = check_qmt_health()
            heartbeat_cache.update(qmt_status)
        
        time.sleep(1.0)  # 1ç§’é—´éš”
```

**å»ºè®®**: å°†100mså»¶è¿Ÿæ£€æµ‹é™ä½åˆ°1ç§’,æˆ–é‡‡ç”¨"è½¯å¿ƒè·³"(ç¼“å­˜+å¼‚æ­¥æ£€æµ‹)

#### å†å²æ•°æ®å®Œæ•´æ€§åˆ†æ

**QMTå†å²æ•°æ®èƒ½åŠ›**:

| æ•°æ®ç±»å‹ | æ—¶é—´èŒƒå›´ | æ›´æ–°é¢‘ç‡ | å®Œæ•´æ€§ |
|---------|---------|---------|--------|
| **æ—¥çº¿** | 1990å¹´è‡³ä»Š | æ¯æ—¥ | âœ… 100% |
| **åˆ†é’Ÿçº¿** | æœ€è¿‘1å¹´ | æ¯æ—¥ | âœ… 95% |
| **Tickæ•°æ®** | æœ€è¿‘3å¤© | å®æ—¶ | âœ… 90% |
| **Level-2é€ç¬”** | æœ€è¿‘3å¤© | å®æ—¶ | âš ï¸ éœ€ä»˜è´¹ |

**å†å²æ•°æ®è·å–ä»£ç **:

```python
# è·å–æ—¥çº¿æ•°æ®
def get_daily_data(code, start_date='20200101'):
    data = qmt.xtdata.get_market_data_ex(
        stock_list=[code],
        period='1d',
        start_time=start_date,
        count=-1,
        dividend_type='front'  # å‰å¤æƒ
    )
    return data[code]

# è·å–åˆ†é’Ÿçº¿æ•°æ®
def get_minute_data(code, period='1m', count=240):
    """è·å–æœ€è¿‘240æ¡1åˆ†é’Ÿæ•°æ®"""
    data = qmt.xtdata.get_market_data(
        stock_list=[code],
        period=period,
        count=count
    )
    return data[code]
```

**æ•°æ®å®Œæ•´æ€§éªŒè¯**:

```python
def validate_qmt_history_completeness():
    """éªŒè¯QMTå†å²æ•°æ®å®Œæ•´æ€§"""
    # éªŒè¯æ—¥çº¿æ•°æ®
    daily_data = get_daily_data('000001.SZ')
    assert len(daily_data) > 5000  # è‡³å°‘5000æ¡æ•°æ®
    
    # éªŒè¯åˆ†é’Ÿçº¿æ•°æ®
    minute_data = get_minute_data('000001.SZ', count=240)
    assert len(minute_data) == 240  # å¿…é¡»æ˜¯240æ¡
    
    # éªŒè¯æ•°æ®è¿ç»­æ€§
    time_diff = daily_data.index.to_series().diff()
    assert time_diff.max() < pd.Timedelta(days=7)  # æœ€å¤šé—´éš”7å¤©
```

### 1.3 Tushare Proç¾å¤‡èƒ½åŠ›

#### ç§¯åˆ†æ¶ˆè€—é€Ÿåº¦åˆ†æ

**Tushareç§¯åˆ†è§„åˆ™** (åŸºäºå®˜æ–¹æ–‡æ¡£):

| APIæ¥å£ | ç§¯åˆ†/æ¬¡ | é¢‘ç‡é™åˆ¶ | é€‚åˆåœºæ™¯ |
|---------|---------|---------|---------|
| `daily` | 0.1 | 1000æ¬¡/åˆ†é’Ÿ | âœ… å†å²æ•°æ® |
| `moneyflow` | 0.5 | 200æ¬¡/åˆ†é’Ÿ | âš ï¸ èµ„é‡‘æµ(å†å²) |
| `realtime_quotes` | 1.0 | 100æ¬¡/åˆ†é’Ÿ | âŒ å®æ—¶è¡Œæƒ…(ä¸æ¨è) |
| `index_daily` | 0.1 | 1000æ¬¡/åˆ†é’Ÿ | âœ… æŒ‡æ•°æ•°æ® |

**ç§¯åˆ†æ¶ˆè€—è®¡ç®—**:

```python
# åœºæ™¯1: å…¨å¸‚åœºèµ„é‡‘æµ (5000åªè‚¡ç¥¨)
def calculate_moneyflow_cost():
    """è®¡ç®—å…¨å¸‚åœºèµ„é‡‘æµç§¯åˆ†æ¶ˆè€—"""
    requests_per_day = 5000  # æ¯å¤©æŸ¥è¯¢5000åªè‚¡ç¥¨
    points_per_request = 0.5  # æ¯æ¬¡æ¶ˆè€—0.5ç§¯åˆ†
    total_points = requests_per_day * points_per_request
    return total_points  # è¾“å‡º: 2500ç§¯åˆ†/å¤©

# åœºæ™¯2: å®æ—¶è¡Œæƒ… (100åªè‚¡ç¥¨)
def calculate_realtime_cost():
    """è®¡ç®—å®æ—¶è¡Œæƒ…ç§¯åˆ†æ¶ˆè€—"""
    requests_per_day = 100 * 60 * 4  # 100åªè‚¡ç¥¨ * 60åˆ†é’Ÿ * 4å°æ—¶
    points_per_request = 1.0  # æ¯æ¬¡æ¶ˆè€—1.0ç§¯åˆ†
    total_points = requests_per_day * points_per_request
    return total_points  # è¾“å‡º: 24000ç§¯åˆ†/å¤©
```

**ç»“è®º**:
- âœ… **å†å²æ•°æ®**: æ¶ˆè€—å¯æ¥å— (2500ç§¯åˆ†/å¤©)
- âŒ **å®æ—¶è¡Œæƒ…**: æ¶ˆè€—è¿‡å¤§ (24000ç§¯åˆ†/å¤©),ä¸é€‚åˆå®ç›˜ç¾å¤‡

#### å®æ—¶æ•°æ®é™åˆ¶åˆ†æ

**Tushareå®æ—¶æ•°æ®é™åˆ¶**:

1. **å»¶è¿Ÿ**: T+1æ•°æ®,æ— çœŸæ­£å®æ—¶æ•°æ®
2. **é¢‘ç‡é™åˆ¶**: 100æ¬¡/åˆ†é’Ÿ,æ— æ³•æ»¡è¶³é«˜é¢‘éœ€æ±‚
3. **æ•°æ®è´¨é‡**: éƒ¨åˆ†å­—æ®µç¼ºå¤±(å¦‚ç›˜å£æ•°æ®)
4. **ç¨³å®šæ€§**: ä¾èµ–ç¬¬ä¸‰æ–¹æ¥å£,å¯èƒ½é™æµ

**ä»£ç ç¤ºä¾‹**:

```python
# âŒ ä¸æ¨è: Tushareå®æ—¶æ•°æ®
def get_tushare_realtime():
    """Tushareå®æ—¶æ•°æ® - ä¸æ¨èç”¨äºå®ç›˜"""
    df = ts.realtime_boxoffice()  # å®æ—¶æ•°æ®æ¥å£
    # é—®é¢˜1: æ•°æ®å»¶è¿Ÿ(5-10ç§’)
    # é—®é¢˜2: é¢‘ç‡é™åˆ¶(100æ¬¡/åˆ†é’Ÿ)
    # é—®é¢˜3: æ•°æ®ä¸å®Œæ•´(ç¼ºå°‘ç›˜å£)
    return df

# âœ… æ¨è: Tushareå†å²æ•°æ®
def get_tushare_history(code):
    """Tushareå†å²æ•°æ® - é€‚åˆç¾å¤‡"""
    df = ts.pro_bar(
        ts_code=code,
        start_date='20200101',
        adj='qfq'
    )
    # ä¼˜åŠ¿1: æ•°æ®å®Œæ•´
    # ä¼˜åŠ¿2: æ— é¢‘ç‡é™åˆ¶
    # ä¼˜åŠ¿3: æˆæœ¬ä½(0.1ç§¯åˆ†/æ¬¡)
    return df
```

#### å®ç›˜ç¾å¤‡é€‚ç”¨æ€§è¯„ä¼°

**è¯„åˆ†è¡¨** (æ»¡åˆ†10åˆ†):

| ç»´åº¦ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| **å®æ—¶æ€§** | 2/10 | T+1æ•°æ®,æ— æ³•ç”¨äºå®æ—¶å†³ç­– |
| **ç¨³å®šæ€§** | 8/10 | å®˜æ–¹API,ç¨³å®šæ€§é«˜ |
| **æˆæœ¬** | 6/10 | å®æ—¶æ•°æ®æˆæœ¬é«˜ |
| **æ•°æ®è´¨é‡** | 7/10 | å†å²æ•°æ®è´¨é‡å¥½,å®æ—¶æ•°æ®ä¸å®Œæ•´ |
| **é¢‘ç‡é™åˆ¶** | 3/10 | 100æ¬¡/åˆ†é’Ÿ,æ— æ³•æ»¡è¶³é«˜é¢‘éœ€æ±‚ |
| **ç»¼åˆè¯„åˆ†** | **5.2/10** | **ä¸é€‚åˆå®ç›˜ç¾å¤‡** |

**ç»“è®º**: Tushare Proä¸é€‚åˆä½œä¸ºå®ç›˜ç¾å¤‡æ•°æ®æº,åªèƒ½ä½œä¸ºå†å²æ•°æ®è¡¥å……ã€‚

#### ç§¯åˆ†æ¶ˆè€—ä¼˜åŒ–æ–¹æ¡ˆ

```python
# æ–¹æ¡ˆ1: æ•°æ®ç¼“å­˜ (æ¨è)
class TushareCache:
    """Tushareæ•°æ®ç¼“å­˜ - é™ä½ç§¯åˆ†æ¶ˆè€—"""
    def __init__(self):
        self.cache = {}
        self.cache_ttl = 86400  # 24å°æ—¶
    
    def get_daily_data(self, code):
        cache_key = f"daily_{code}"
        if cache_key in self.cache:
            if time.time() - self.cache[cache_key]['timestamp'] < self.cache_ttl:
                return self.cache[cache_key]['data']
        
        # ç¼“å­˜è¿‡æœŸ,é‡æ–°è·å–
        data = ts.pro_bar(ts_code=code)
        self.cache[cache_key] = {
            'data': data,
            'timestamp': time.time()
        }
        return data

# æ–¹æ¡ˆ2: æ‰¹é‡è·å– (æ¨è)
def get_daily_data_batch(codes):
    """æ‰¹é‡è·å–æ—¥çº¿æ•°æ® - é™ä½è¯·æ±‚æ¬¡æ•°"""
    # ä½¿ç”¨ts.pro_baræ‰¹é‡æ¥å£
    df = ts.pro_bar(
        ts_code=','.join(codes),
        start_date='20200101'
    )
    return df

# æ–¹æ¡ˆ3: æœ¬åœ°å­˜å‚¨ (æ¨è)
def save_to_local():
    """å°†Tushareæ•°æ®ä¿å­˜åˆ°æœ¬åœ°,å‡å°‘é‡å¤è·å–"""
    codes = get_all_codes()
    for code in codes:
        data = ts.pro_bar(ts_code=code)
        data.to_csv(f"data/tushare/{code}.csv")
    
    # ä»¥åç›´æ¥ä»æœ¬åœ°è¯»å–
    df = pd.read_csv(f"data/tushare/000001.SZ.csv")
```

---

## 2. Fail-Safeæœºåˆ¶æŠ€æœ¯åˆ†æ

### 2.1 å¿ƒè·³æ£€æµ‹å®ç°

#### 100mså»¶è¿Ÿæ£€æµ‹çš„æŠ€æœ¯å®ç°

**CTOè¦æ±‚**: "100mså»¶è¿Ÿæ£€æµ‹"

**æŠ€æœ¯å¯è¡Œæ€§åˆ†æ**:

```python
# âŒ æ–¹æ¡ˆ1: åŒæ­¥æ£€æµ‹ (ä¸å¯è¡Œ)
def heartbeat_sync():
    """åŒæ­¥å¿ƒè·³æ£€æµ‹ - 100msä¸å¯è¡Œ"""
    while True:
        start = time.time()
        
        # æ£€æµ‹QMTè¿æ¥ (è€—æ—¶0.3ç§’)
        qmt_status = check_qmt_connection()
        
        # æ£€æµ‹æ•°æ®è´¨é‡ (è€—æ—¶0.2ç§’)
        data_quality = check_data_quality()
        
        elapsed = time.time() - start  # æ€»è€—æ—¶0.5ç§’
        
        if elapsed > 0.1:
            logger.error(f"å¿ƒè·³æ£€æµ‹è¶…æ—¶: {elapsed*1000:.0f}ms")
            trigger_fail_safe()
        
        time.sleep(0.1)  # 100msé—´éš”
        # å®é™…æ€»è€—æ—¶ = 0.5ç§’(æ£€æµ‹) + 0.1ç§’(ä¼‘çœ ) = 0.6ç§’
        # æ— æ³•æ»¡è¶³100msè¦æ±‚

# âœ… æ–¹æ¡ˆ2: å¼‚æ­¥æ£€æµ‹ (å¯è¡Œ)
async def heartbeat_async():
    """å¼‚æ­¥å¿ƒè·³æ£€æµ‹ - å¯è¡Œ"""
    while True:
        start = time.time()
        
        # å¹¶å‘æ£€æµ‹QMTè¿æ¥å’Œæ•°æ®è´¨é‡
        qmt_status, data_quality = await asyncio.gather(
            check_qmt_connection_async(),
            check_data_quality_async()
        )
        
        elapsed = time.time() - start  # æ€»è€—æ—¶0.3ç§’
        
        if elapsed > 0.3:
            logger.error(f"å¿ƒè·³æ£€æµ‹è¶…æ—¶: {elapsed*1000:.0f}ms")
            trigger_fail_safe()
        
        await asyncio.sleep(0.1)  # 100msé—´éš”

# âœ… æ–¹æ¡ˆ3: è½¯å¿ƒè·³ (æ¨è)
class SoftHeartbeat:
    """è½¯å¿ƒè·³æ£€æµ‹ - æ¨è"""
    def __init__(self):
        self.qmt_status_cache = None
        self.data_quality_cache = None
        self.last_check_time = 0
        self.check_interval = 1.0  # 1ç§’æ£€æµ‹ä¸€æ¬¡
    
    def check(self):
        """è½¯å¿ƒè·³æ£€æµ‹"""
        current_time = time.time()
        
        # å¦‚æœè·ç¦»ä¸Šæ¬¡æ£€æµ‹è¶…è¿‡1ç§’,æ‰é‡æ–°æ£€æµ‹
        if current_time - self.last_check_time > self.check_interval:
            self.qmt_status_cache = check_qmt_connection()
            self.data_quality_cache = check_data_quality()
            self.last_check_time = current_time
        
        # è¿”å›ç¼“å­˜ç»“æœ (è€—æ—¶<1ms)
        return {
            'qmt_status': self.qmt_status_cache,
            'data_quality': self.data_quality_cache,
            'elapsed': current_time - self.last_check_time
        }
```

**å»ºè®®**: é‡‡ç”¨"è½¯å¿ƒè·³"æ–¹æ¡ˆ,å®é™…æ£€æµ‹é¢‘ç‡1ç§’,ä½†è°ƒç”¨å»¶è¿Ÿ<1ms

#### QMTè¿æ¥çŠ¶æ€æ£€æµ‹

**æ£€æµ‹ç»´åº¦**:

| ç»´åº¦ | æ£€æµ‹æ–¹æ³• | é˜ˆå€¼ | å¤„ç†æ–¹å¼ |
|------|---------|------|---------|
| **å®¢æˆ·ç«¯çŠ¶æ€** | `xtdata.is_connected()` | å¿…é¡»True | é™çº§åˆ°EasyQuotation |
| **ç™»å½•çŠ¶æ€** | `xtdata.get_client_status()` | å·²ç™»å½• | æç¤ºé‡æ–°ç™»å½• |
| **è¡Œæƒ…ä¸»ç«™** | `get_market_status()` | å·²è¿æ¥ | ç­‰å¾…é‡è¿ |
| **è®¢é˜…çŠ¶æ€** | `get_subscribed_codes()` | è®¢é˜…æˆåŠŸ | é‡æ–°è®¢é˜… |

**å®ç°ä»£ç **:

```python
class QMTHealthChecker:
    """QMTå¥åº·æ£€æŸ¥å™¨"""
    
    def __init__(self):
        self.qmt = get_qmt_manager()
        self.last_status = None
        self.error_count = 0
        self.max_errors = 3
    
    def check_connection(self):
        """æ£€æŸ¥QMTè¿æ¥çŠ¶æ€"""
        try:
            # æ£€æŸ¥1: å®¢æˆ·ç«¯çŠ¶æ€
            if not self.qmt.is_connected():
                raise QMTNotConnectedError("QMTå®¢æˆ·ç«¯æœªè¿æ¥")
            
            # æ£€æŸ¥2: ç™»å½•çŠ¶æ€
            status = self.qmt.get_client_status()
            if not status.get('logged_in'):
                raise QMTNotLoggedInError("QMTæœªç™»å½•")
            
            # æ£€æŸ¥3: è¡Œæƒ…ä¸»ç«™
            market_status = self.qmt.get_market_status()
            if not market_status.get('connected'):
                raise QMTMarketDisconnectedError("è¡Œæƒ…ä¸»ç«™æœªè¿æ¥")
            
            # æ£€æŸ¥4: æ•°æ®è´¨é‡
            test_data = self.qmt.get_full_tick(['000001.SZ'])
            if not test_data:
                raise QMTDataError("æ— æ³•è·å–æµ‹è¯•æ•°æ®")
            
            # æ‰€æœ‰æ£€æŸ¥é€šè¿‡
            self.error_count = 0
            return {
                'status': 'OK',
                'client': 'connected',
                'logged_in': True,
                'market': 'connected',
                'data_quality': 'good'
            }
            
        except Exception as e:
            self.error_count += 1
            logger.error(f"QMTå¥åº·æ£€æŸ¥å¤±è´¥: {e}")
            
            # è¿ç»­å¤±è´¥3æ¬¡,è§¦å‘Fail-Safe
            if self.error_count >= self.max_errors:
                trigger_fail_safe(f"QMTè¿ç»­å¤±è´¥{self.max_errors}æ¬¡")
            
            return {
                'status': 'ERROR',
                'error': str(e),
                'error_count': self.error_count
            }
```

#### æ•°æ®è´¨é‡æ£€æµ‹

**æ£€æµ‹ç»´åº¦**:

| ç»´åº¦ | æ£€æµ‹æ–¹æ³• | é˜ˆå€¼ | å¤„ç†æ–¹å¼ |
|------|---------|------|---------|
| **æ•°æ®æ—¶æ•ˆæ€§** | `data['timestamp']` | <5ç§’ | æ ‡è®°ä¸ºè¿‡æœŸæ•°æ® |
| **æ•°æ®å®Œæ•´æ€§** | `len(data)` | >0 | æ ‡è®°ä¸ºç¼ºå¤±æ•°æ® |
| **ä»·æ ¼åˆç†æ€§** | `price > 0` | å¿…é¡» | æ ‡è®°ä¸ºå¼‚å¸¸æ•°æ® |
| **æˆäº¤é‡åˆç†æ€§** | `volume >= 0` | å¿…é¡» | æ ‡è®°ä¸ºå¼‚å¸¸æ•°æ® |
| **æ•°æ®ä¸€è‡´æ€§** | `price in [low, high]` | å¿…é¡» | æ ‡è®°ä¸ºå¼‚å¸¸æ•°æ® |

**å®ç°ä»£ç **:

```python
class DataQualityChecker:
    """æ•°æ®è´¨é‡æ£€æŸ¥å™¨"""
    
    def check_data_quality(self, data):
        """æ£€æŸ¥æ•°æ®è´¨é‡"""
        issues = []
        
        # æ£€æŸ¥1: æ•°æ®æ—¶æ•ˆæ€§
        current_time = time.time()
        data_time = data.get('timestamp', 0)
        if current_time - data_time > 5:
            issues.append({
                'type': 'STALE_DATA',
                'severity': 'WARNING',
                'message': f"æ•°æ®è¿‡æœŸ: {current_time - data_time:.1f}ç§’"
            })
        
        # æ£€æŸ¥2: æ•°æ®å®Œæ•´æ€§
        if not data:
            issues.append({
                'type': 'MISSING_DATA',
                'severity': 'ERROR',
                'message': "æ•°æ®ä¸ºç©º"
            })
            return issues
        
        # æ£€æŸ¥3: ä»·æ ¼åˆç†æ€§
        price = data.get('price', 0)
        if price <= 0:
            issues.append({
                'type': 'INVALID_PRICE',
                'severity': 'ERROR',
                'message': f"ä»·æ ¼å¼‚å¸¸: {price}"
            })
        
        # æ£€æŸ¥4: æˆäº¤é‡åˆç†æ€§
        volume = data.get('volume', 0)
        if volume < 0:
            issues.append({
                'type': 'INVALID_VOLUME',
                'severity': 'ERROR',
                'message': f"æˆäº¤é‡å¼‚å¸¸: {volume}"
            })
        
        # æ£€æŸ¥5: æ•°æ®ä¸€è‡´æ€§
        low = data.get('low', 0)
        high = data.get('high', 0)
        if not (low <= price <= high):
            issues.append({
                'type': 'INCONSISTENT_DATA',
                'severity': 'ERROR',
                'message': f"ä»·æ ¼ä¸ä¸€è‡´: price={price}, low={low}, high={high}"
            })
        
        return issues
```

#### è¯¯è§¦å‘é£é™©

**è¯¯è§¦å‘åœºæ™¯**:

| åœºæ™¯ | åŸå›  | é˜ˆå€¼ | è¯¯è§¦å‘æ¦‚ç‡ |
|------|------|------|-----------|
| **ç½‘ç»œæŠ–åŠ¨** | ç½‘ç»œå»¶è¿Ÿ>1ç§’ | 100ms | ğŸ”´ é«˜ (50%) |
| **QMTè´Ÿè½½é«˜** | QMTå“åº”æ…¢ | 100ms | ğŸ”´ é«˜ (40%) |
| **æ•°æ®å»¶è¿Ÿ** | è¡Œæƒ…æ•°æ®å»¶è¿Ÿ | 5ç§’ | ğŸŸ¡ ä¸­ (20%) |
| **ç³»ç»Ÿè´Ÿè½½** | CPU/å†…å­˜å ç”¨é«˜ | 100ms | ğŸŸ¡ ä¸­ (15%) |

**é˜²è¯¯è§¦å‘æœºåˆ¶**:

```python
class AntiFalseTrigger:
    """é˜²è¯¯è§¦å‘æœºåˆ¶"""
    
    def __init__(self):
        self.error_history = []
        self.trigger_threshold = 3  # è¿ç»­3æ¬¡é”™è¯¯æ‰è§¦å‘
        self.time_window = 60  # 60ç§’æ—¶é—´çª—å£
    
    def check_should_trigger(self, error):
        """æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘Fail-Safe"""
        current_time = time.time()
        
        # è®°å½•é”™è¯¯
        self.error_history.append({
            'time': current_time,
            'error': error
        })
        
        # æ¸…ç†è¿‡æœŸè®°å½• (60ç§’å¤–çš„è®°å½•)
        self.error_history = [
            e for e in self.error_history
            if current_time - e['time'] < self.time_window
        ]
        
        # æ£€æŸ¥æ˜¯å¦è¾¾åˆ°è§¦å‘é˜ˆå€¼
        if len(self.error_history) >= self.trigger_threshold:
            # æ£€æŸ¥æ˜¯å¦æ˜¯è¿ç»­é”™è¯¯
            if all(e['error'] == error for e in self.error_history):
                return True
        
        return False
```

### 2.2 Kill Switchå®ç°

#### ç´§æ€¥å¹³ä»“çš„æŠ€æœ¯å®ç°

**å¹³ä»“é€»è¾‘**:

```python
class EmergencyCloser:
    """ç´§æ€¥å¹³ä»“å™¨"""
    
    def __init__(self):
        self.qmt = get_qmt_manager()
        self.positions = get_current_positions()
    
    def close_all_positions(self, reason="ç´§æ€¥å¹³ä»“"):
        """ç´§æ€¥å¹³ä»“æ‰€æœ‰æŒä»“"""
        logger.critical(f"ğŸš¨ ç´§æ€¥å¹³ä»“è§¦å‘: {reason}")
        
        for position in self.positions:
            try:
                # å¹³ä»“é€»è¾‘
                order = self.qmt.order_stock(
                    stock_code=position['code'],
                    order_type='sell',
                    volume=position['volume'],
                    price_type='market'  # å¸‚ä»·å•,å¿«é€Ÿæˆäº¤
                )
                
                logger.info(f"âœ… å¹³ä»“æˆåŠŸ: {position['code']}")
                
            except Exception as e:
                logger.error(f"âŒ å¹³ä»“å¤±è´¥: {position['code']}, {e}")
        
        # è®°å½•åˆ°æ—¥å¿—
        self.log_emergency_close(reason)
    
    def log_emergency_close(self, reason):
        """è®°å½•ç´§æ€¥å¹³ä»“æ—¥å¿—"""
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'reason': reason,
            'positions': self.positions,
            'total_value': sum(p['value'] for p in self.positions)
        }
        
        with open('logs/emergency_close.log', 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
```

**å¹³ä»“ç­–ç•¥**:

| ç­–ç•¥ | é€Ÿåº¦ | æ»‘ç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| **å¸‚ä»·å•** | âš¡ æœ€å¿« | ğŸ“ˆ å¤§ (0.5-1%) | ğŸ”´ ç´§æ€¥æƒ…å†µ |
| **é™ä»·å•** | ğŸ¢ æ…¢ | ğŸ“‰ å° (0.1-0.2%) | ğŸŸ¡ æ™®é€šæƒ…å†µ |
| **åˆ†æ‰¹å¹³ä»“** | â³ ä¸­ | ğŸ“Š ä¸­ (0.3-0.5%) | ğŸŸ¢ å¤§èµ„é‡‘ |

**å»ºè®®**: ç´§æ€¥æƒ…å†µä½¿ç”¨å¸‚ä»·å•,æ™®é€šæƒ…å†µä½¿ç”¨é™ä»·å•

#### å‘Šè­¦ç³»ç»Ÿçš„æŠ€æœ¯å®ç°

**å‘Šè­¦çº§åˆ«**:

| çº§åˆ« | è§¦å‘æ¡ä»¶ | é€šçŸ¥æ–¹å¼ | å“åº”æ—¶é—´ |
|------|---------|---------|---------|
| **P0 - ç´§æ€¥** | QMTæ–­è¿ã€æ•°æ®å¼‚å¸¸ | çŸ­ä¿¡+ç”µè¯+é‚®ä»¶ | <1åˆ†é’Ÿ |
| **P1 - ä¸¥é‡** | è¿ç»­å¤±è´¥3æ¬¡ | çŸ­ä¿¡+é‚®ä»¶ | <5åˆ†é’Ÿ |
| **P2 - è­¦å‘Š** | å•æ¬¡å¤±è´¥ | é‚®ä»¶ | <30åˆ†é’Ÿ |
| **P3 - æç¤º** | æ€§èƒ½ä¸‹é™ | é‚®ä»¶ | <1å°æ—¶ |

**å®ç°ä»£ç **:

```python
class AlertSystem:
    """å‘Šè­¦ç³»ç»Ÿ"""
    
    def __init__(self):
        self.alert_history = []
        self.cooldown = 300  # 5åˆ†é’Ÿå†·å´æ—¶é—´
    
    def send_alert(self, level, message, context=None):
        """å‘é€å‘Šè­¦"""
        current_time = time.time()
        
        # æ£€æŸ¥å†·å´æ—¶é—´
        if self._is_in_cooldown(level, message):
            logger.info(f"å‘Šè­¦å†·å´ä¸­: {message}")
            return
        
        # å‘é€å‘Šè­¦
        if level == 'P0':
            self._send_sms(message)
            self._send_phone_call(message)
            self._send_email(message)
        elif level == 'P1':
            self._send_sms(message)
            self._send_email(message)
        elif level == 'P2':
            self._send_email(message)
        
        # è®°å½•å‘Šè­¦
        self.alert_history.append({
            'timestamp': current_time,
            'level': level,
            'message': message,
            'context': context
        })
    
    def _is_in_cooldown(self, level, message):
        """æ£€æŸ¥æ˜¯å¦åœ¨å†·å´æœŸ"""
        current_time = time.time()
        recent_alerts = [
            a for a in self.alert_history
            if a['level'] == level and a['message'] == message
            and current_time - a['timestamp'] < self.cooldown
        ]
        return len(recent_alerts) > 0
    
    def _send_sms(self, message):
        """å‘é€çŸ­ä¿¡"""
        # ä½¿ç”¨é˜¿é‡Œäº‘çŸ­ä¿¡æœåŠ¡
        from aliyunsdkcore.client import AcsClient
        from aliyunsdkdysmsapi.request.v20170525 import SendSmsRequest
        
        client = AcsClient('ACCESS_KEY', 'SECRET_KEY', 'cn-hangzhou')
        request = SendSmsRequest()
        request.set_PhoneNumbers("13800138000")
        request.set_SignName("é‡åŒ–äº¤æ˜“ç³»ç»Ÿ")
        request.set_TemplateCode("SMS_123456789")
        request.set_TemplateParam(f'{{"message":"{message}"}}')
        
        response = client.do_action_with_exception(request)
        logger.info(f"çŸ­ä¿¡å‘é€æˆåŠŸ: {response}")
    
    def _send_email(self, message):
        """å‘é€é‚®ä»¶"""
        import smtplib
        from email.mime.text import MIMEText
        
        msg = MIMEText(message)
        msg['Subject'] = f"é‡åŒ–äº¤æ˜“ç³»ç»Ÿå‘Šè­¦: {message}"
        msg['From'] = "system@myquant.com"
        msg['To'] = "admin@myquant.com"
        
        with smtplib.SMTP('smtp.exmail.qq.com', 465) as server:
            server.login("system@myquant.com", "password")
            server.send_message(msg)
        
        logger.info(f"é‚®ä»¶å‘é€æˆåŠŸ: {message}")
```

#### æ‰‹åŠ¨é‡å¯çš„æŠ€æœ¯å®ç°

**é‡å¯ç­–ç•¥**:

| é‡å¯æ–¹å¼ | é€Ÿåº¦ | æ•°æ®ä¿ç•™ | é€‚ç”¨åœºæ™¯ |
|---------|------|---------|---------|
| **è½¯é‡å¯** | âš¡ å¿« (1-2ç§’) | âœ… ä¿ç•™ | ğŸŸ¢ æ™®é€šæƒ…å†µ |
| **ç¡¬é‡å¯** | ğŸ¢ æ…¢ (10-30ç§’) | âŒ ä¸ä¿ç•™ | ğŸ”´ ä¸¥é‡æƒ…å†µ |
| **åˆ†æ­¥é‡å¯** | â³ ä¸­ | âœ… ä¿ç•™ | ğŸŸ¡ è°¨æ…æƒ…å†µ |

**å®ç°ä»£ç **:

```python
class SystemRestarter:
    """ç³»ç»Ÿé‡å¯å™¨"""
    
    def __init__(self):
        self.qmt = get_qmt_manager()
        self.data_manager = get_data_manager()
    
    def soft_restart(self):
        """è½¯é‡å¯ - ä¿ç•™æ•°æ®"""
        logger.info("ğŸ”„ å¼€å§‹è½¯é‡å¯...")
        
        # æ­¥éª¤1: åœæ­¢æ•°æ®è·å–
        self.qmt.stop()
        logger.info("âœ… åœæ­¢æ•°æ®è·å–")
        
        # æ­¥éª¤2: ä¿å­˜å½“å‰çŠ¶æ€
        self.save_current_state()
        logger.info("âœ… ä¿å­˜å½“å‰çŠ¶æ€")
        
        # æ­¥éª¤3: æ¸…ç†ç¼“å­˜
        self.clear_cache()
        logger.info("âœ… æ¸…ç†ç¼“å­˜")
        
        # æ­¥éª¤4: é‡æ–°åˆå§‹åŒ–
        self.qmt.restart()
        logger.info("âœ… é‡æ–°åˆå§‹åŒ–QMT")
        
        # æ­¥éª¤5: æ¢å¤çŠ¶æ€
        self.restore_state()
        logger.info("âœ… æ¢å¤çŠ¶æ€")
        
        logger.info("âœ… è½¯é‡å¯å®Œæˆ")
    
    def hard_restart(self):
        """ç¡¬é‡å¯ - ä¸ä¿ç•™æ•°æ®"""
        logger.critical("ğŸš¨ å¼€å§‹ç¡¬é‡å¯...")
        
        # æ­¥éª¤1: ç´§æ€¥å¹³ä»“
        self.emergency_close("ç¡¬é‡å¯å‰å¹³ä»“")
        
        # æ­¥éª¤2: åœæ­¢æ‰€æœ‰æœåŠ¡
        self.stop_all_services()
        
        # æ­¥éª¤3: æ¸…ç†æ‰€æœ‰æ•°æ®
        self.clear_all_data()
        
        # æ­¥éª¤4: é‡å¯QMTå®¢æˆ·ç«¯
        self.restart_qmt_client()
        
        # æ­¥éª¤5: é‡æ–°åˆå§‹åŒ–ç³»ç»Ÿ
        self.initialize_system()
        
        logger.critical("âœ… ç¡¬é‡å¯å®Œæˆ")
    
    def save_current_state(self):
        """ä¿å­˜å½“å‰çŠ¶æ€"""
        state = {
            'timestamp': datetime.now().isoformat(),
            'positions': get_current_positions(),
            'opportunities': get_current_opportunities(),
            'watchlist': get_current_watchlist()
        }
        
        with open('data/system_state.json', 'w') as f:
            json.dump(state, f, indent=2)
    
    def restore_state(self):
        """æ¢å¤çŠ¶æ€"""
        with open('data/system_state.json', 'r') as f:
            state = json.load(f)
        
        # æ¢å¤æŒä»“
        for position in state['positions']:
            restore_position(position)
        
        # æ¢å¤æœºä¼šæ± 
        for opportunity in state['opportunities']:
            restore_opportunity(opportunity)
```

#### ç³»ç»Ÿæ¢å¤çš„æŠ€æœ¯å®ç°

**æ¢å¤ç­–ç•¥**:

```python
class SystemRecovery:
    """ç³»ç»Ÿæ¢å¤å™¨"""
    
    def __init__(self):
        self.checklist = [
            'qmt_connection',
            'data_quality',
            'positions',
            'opportunities',
            'strategies'
        ]
    
    def recover(self):
        """ç³»ç»Ÿæ¢å¤"""
        logger.info("ğŸ”§ å¼€å§‹ç³»ç»Ÿæ¢å¤...")
        
        for item in self.checklist:
            try:
                self._recover_item(item)
                logger.info(f"âœ… æ¢å¤æˆåŠŸ: {item}")
            except Exception as e:
                logger.error(f"âŒ æ¢å¤å¤±è´¥: {item}, {e}")
                # å°è¯•é™çº§æ¢å¤
                self._fallback_recover(item)
        
        # éªŒè¯æ¢å¤ç»“æœ
        self._verify_recovery()
        
        logger.info("âœ… ç³»ç»Ÿæ¢å¤å®Œæˆ")
    
    def _recover_item(self, item):
        """æ¢å¤å•ä¸ªé¡¹ç›®"""
        if item == 'qmt_connection':
            self._recover_qmt_connection()
        elif item == 'data_quality':
            self._recover_data_quality()
        elif item == 'positions':
            self._recover_positions()
        # ... å…¶ä»–é¡¹ç›®
    
    def _verify_recovery(self):
        """éªŒè¯æ¢å¤ç»“æœ"""
        # éªŒè¯QMTè¿æ¥
        assert self.qmt.is_connected(), "QMTè¿æ¥å¤±è´¥"
        
        # éªŒè¯æ•°æ®è´¨é‡
        test_data = self.qmt.get_full_tick(['000001.SZ'])
        assert test_data, "æ•°æ®è·å–å¤±è´¥"
        
        # éªŒè¯æŒä»“
        positions = get_current_positions()
        logger.info(f"å½“å‰æŒä»“: {len(positions)}åª")
        
        # éªŒè¯ç­–ç•¥
        strategies = get_active_strategies()
        logger.info(f"æ´»è·ƒç­–ç•¥: {len(strategies)}ä¸ª")
```

---

## 3. æ¶æ„é‡æ„æŠ€æœ¯åˆ†æ

### 3.1 5å±‚é’¢é“æ¶æ„æŠ€æœ¯ç»†èŠ‚

#### Layer 1: Core Abstractions (æ ¸å¿ƒæŠ½è±¡å±‚)

**è®¾è®¡æ¨¡å¼**: ä¾èµ–æ³¨å…¥ + å·¥å‚æ¨¡å¼ + ç­–ç•¥æ¨¡å¼

**æ ¸å¿ƒæ¥å£**:

```python
# logic/core/abstractions/data_provider.py
class IDataProvider(ABC):
    """æ•°æ®æä¾›è€…æ¥å£"""
    
    @abstractmethod
    def get_realtime_data(self, codes: List[str]) -> List[Dict]:
        """è·å–å®æ—¶æ•°æ®"""
        pass
    
    @abstractmethod
    def get_history_data(self, code: str, period: str) -> pd.DataFrame:
        """è·å–å†å²æ•°æ®"""
        pass

# logic/core/abstractions/strategy.py
class IStrategy(ABC):
    """ç­–ç•¥æ¥å£"""
    
    @abstractmethod
    def scan(self, market_data: List[Dict]) -> List[Dict]:
        """æ‰«æå¸‚åœº"""
        pass
    
    @abstractmethod
    def execute(self, signal: Dict) -> Dict:
        """æ‰§è¡Œä¿¡å·"""
        pass

# logic/core/abstractions/risk_manager.py
class IRiskManager(ABC):
    """é£é™©ç®¡ç†æ¥å£"""
    
    @abstractmethod
    def check_position_risk(self, position: Dict) -> bool:
        """æ£€æŸ¥æŒä»“é£é™©"""
        pass
    
    @abstractmethod
    def check_market_risk(self, market_data: Dict) -> bool:
        """æ£€æŸ¥å¸‚åœºé£é™©"""
        pass
```

**å·¥å‚å®ç°**:

```python
# logic/core/factories/data_provider_factory.py
class DataProviderFactory:
    """æ•°æ®æä¾›è€…å·¥å‚"""
    
    _providers = {
        'qmt': QMTDataProvider,
        'easyquotation': EasyQuotationProvider,
        'tushare': TushareProvider
    }
    
    @classmethod
    def create(cls, provider_type: str) -> IDataProvider:
        """åˆ›å»ºæ•°æ®æä¾›è€…"""
        provider_class = cls._providers.get(provider_type)
        if not provider_class:
            raise ValueError(f"æœªçŸ¥çš„æ•°æ®æä¾›è€…: {provider_type}")
        return provider_class()
    
    @classmethod
    def create_with_fallback(cls, preferred_type: str) -> IDataProvider:
        """åˆ›å»ºå¸¦é™çº§çš„æ•°æ®æä¾›è€…"""
        try:
            return cls.create(preferred_type)
        except Exception as e:
            logger.warning(f"{preferred_type}å¤±è´¥,é™çº§åˆ°é»˜è®¤")
            return cls.create('easyquotation')
```

#### Layer 2: Data Pipeline (æ•°æ®ç®¡é“å±‚)

**å®ç°æ–¹å¼**: è´£ä»»é“¾æ¨¡å¼ + ç®¡é“è¿‡æ»¤å™¨æ¨¡å¼

**ç®¡é“è®¾è®¡**:

```python
# logic/pipelines/data_pipeline.py
class DataPipeline:
    """æ•°æ®ç®¡é“"""
    
    def __init__(self):
        self.stages = [
            DataValidationStage(),
            DataNormalizationStage(),
            DataEnrichmentStage(),
            DataQualityCheckStage()
        ]
    
    def process(self, raw_data: List[Dict]) -> List[Dict]:
        """å¤„ç†æ•°æ®"""
        data = raw_data
        
        for stage in self.stages:
            try:
                data = stage.process(data)
            except Exception as e:
                logger.error(f"ç®¡é“é˜¶æ®µå¤±è´¥: {stage.__class__.__name__}, {e}")
                # ç»§ç»­å¤„ç†ä¸‹ä¸€é˜¶æ®µ,ä¸ä¸­æ–­æ•´ä¸ªç®¡é“
                continue
        
        return data

# logic/pipelines/stages/validation_stage.py
class DataValidationStage:
    """æ•°æ®éªŒè¯é˜¶æ®µ"""
    
    def process(self, data: List[Dict]) -> List[Dict]:
        """éªŒè¯æ•°æ®"""
        validated_data = []
        
        for item in data:
            if self._is_valid(item):
                validated_data.append(item)
            else:
                logger.warning(f"æ•°æ®éªŒè¯å¤±è´¥: {item}")
        
        return validated_data
    
    def _is_valid(self, item: Dict) -> bool:
        """éªŒè¯å•ä¸ªæ•°æ®é¡¹"""
        # æ£€æŸ¥å¿…éœ€å­—æ®µ
        required_fields = ['code', 'price', 'volume']
        for field in required_fields:
            if field not in item:
                return False
        
        # æ£€æŸ¥æ•°æ®åˆç†æ€§
        if item['price'] <= 0:
            return False
        
        if item['volume'] < 0:
            return False
        
        return True

# logic/pipelines/stages/normalization_stage.py
class DataNormalizationStage:
    """æ•°æ®æ ‡å‡†åŒ–é˜¶æ®µ"""
    
    def process(self, data: List[Dict]) -> List[Dict]:
        """æ ‡å‡†åŒ–æ•°æ®"""
        normalized_data = []
        
        for item in data:
            normalized_item = self._normalize(item)
            normalized_data.append(normalized_item)
        
        return normalized_data
    
    def _normalize(self, item: Dict) -> Dict:
        """æ ‡å‡†åŒ–å•ä¸ªæ•°æ®é¡¹"""
        # ç»Ÿä¸€å­—æ®µå
        normalized = {
            'code': item.get('code', item.get('symbol')),
            'name': item.get('name', ''),
            'price': float(item.get('price', item.get('now', 0))),
            'volume': float(item.get('volume', 0)),
            'amount': float(item.get('amount', 0)),
            'change_pct': float(item.get('change_pct', 0)),
            'timestamp': item.get('timestamp', time.time())
        }
        
        # å•ä½è½¬æ¢
        if 'volume_raw' in item:
            # è‚¡æ•°è½¬æ‰‹æ•°
            normalized['volume'] = item['volume_raw'] / 100
        
        if 'amount_raw' in item:
            # å…ƒè½¬ä¸‡å…ƒ
            normalized['amount'] = item['amount_raw'] / 10000
        
        return normalized

# logic/pipelines/stages/enrichment_stage.py
class DataEnrichmentStage:
    """æ•°æ®å¢å¼ºé˜¶æ®µ"""
    
    def __init__(self):
        self.cache = {}
    
    def process(self, data: List[Dict]) -> List[Dict]:
        """å¢å¼ºæ•°æ®"""
        enriched_data = []
        
        for item in data:
            enriched_item = self._enrich(item)
            enriched_data.append(enriched_item)
        
        return enriched_data
    
    def _enrich(self, item: Dict) -> Dict:
        """å¢å¼ºå•ä¸ªæ•°æ®é¡¹"""
        code = item['code']
        
        # æ·»åŠ æŠ€æœ¯æŒ‡æ ‡
        if code not in self.cache:
            self.cache[code] = self._calculate_indicators(code)
        
        item.update(self.cache[code])
        
        # æ·»åŠ è¡ç”Ÿå­—æ®µ
        item['turnover_rate'] = item['volume'] / self._get_circulating_share(code)
        item['volume_ratio'] = item['volume'] / self._get_avg_volume(code, 5)
        
        return item
```

#### Layer 3: Strategy Modules (ç­–ç•¥æ¨¡å—å±‚)

**æŠ½è±¡å±‚æ¬¡**: æ¨¡æ¿æ–¹æ³•æ¨¡å¼ + ç­–ç•¥æ¨¡å¼

**åŸºç±»è®¾è®¡**:

```python
# logic/strategies/base_strategy.py
class BaseStrategy(ABC):
    """ç­–ç•¥åŸºç±»"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.name = self.__class__.__name__
        self.data_pipeline = DataPipeline()
        self.risk_manager = RiskManager()
    
    def execute(self, market_data: List[Dict]) -> List[Dict]:
        """æ‰§è¡Œç­–ç•¥"""
        # æ¨¡æ¿æ–¹æ³•
        data = self._prepare_data(market_data)
        candidates = self._filter_candidates(data)
        signals = self._generate_signals(candidates)
        validated_signals = self._validate_signals(signals)
        
        return validated_signals
    
    @abstractmethod
    def _prepare_data(self, market_data: List[Dict]) -> List[Dict]:
        """å‡†å¤‡æ•°æ®"""
        pass
    
    @abstractmethod
    def _filter_candidates(self, data: List[Dict]) -> List[Dict]:
        """ç­›é€‰å€™é€‰"""
        pass
    
    @abstractmethod
    def _generate_signals(self, candidates: List[Dict]) -> List[Dict]:
        """ç”Ÿæˆä¿¡å·"""
        pass
    
    def _validate_signals(self, signals: List[Dict]) -> List[Dict]:
        """éªŒè¯ä¿¡å·"""
        validated = []
        
        for signal in signals:
            if self.risk_manager.check(signal):
                validated.append(signal)
        
        return validated

# logic/strategies/momentum_strategy.py
class MomentumStrategy(BaseStrategy):
    """åŠ¨é‡ç­–ç•¥"""
    
    def _prepare_data(self, market_data: List[Dict]) -> List[Dict]:
        """å‡†å¤‡æ•°æ®"""
        return self.data_pipeline.process(market_data)
    
    def _filter_candidates(self, data: List[Dict]) -> List[Dict]:
        """ç­›é€‰å€™é€‰"""
        candidates = []
        
        for item in data:
            # ç­›é€‰æ¡ä»¶
            if item['change_pct'] > 5:  # æ¶¨å¹…>5%
                if item['volume_ratio'] > 1.5:  # é‡æ¯”>1.5
                    if item['turnover_rate'] > 3:  # æ¢æ‰‹ç‡>3%
                        candidates.append(item)
        
        return candidates
    
    def _generate_signals(self, candidates: List[Dict]) -> List[Dict]:
        """ç”Ÿæˆä¿¡å·"""
        signals = []
        
        for candidate in candidates:
            signal = {
                'code': candidate['code'],
                'type': 'BUY',
                'price': candidate['price'],
                'confidence': self._calculate_confidence(candidate),
                'reason': f"åŠ¨é‡çªç ´: æ¶¨å¹…{candidate['change_pct']:.2f}%, é‡æ¯”{candidate['volume_ratio']:.2f}"
            }
            signals.append(signal)
        
        return signals
```

#### Layer 4: Task Orchestration (ä»»åŠ¡ç¼–æ’å±‚)

**å°è£…æ–¹å¼**: å‘½ä»¤æ¨¡å¼ + è´£ä»»é“¾æ¨¡å¼

```python
# logic/tasks/task_orchestrator.py
class TaskOrchestrator:
    """ä»»åŠ¡ç¼–æ’å™¨"""
    
    def __init__(self):
        self.task_queue = Queue()
        self.workers = []
        self.running = False
    
    def start(self, num_workers: int = 4):
        """å¯åŠ¨ä»»åŠ¡ç¼–æ’å™¨"""
        self.running = True
        
        for i in range(num_workers):
            worker = TaskWorker(f"worker-{i}", self.task_queue)
            worker.start()
            self.workers.append(worker)
        
        logger.info(f"ä»»åŠ¡ç¼–æ’å™¨å¯åŠ¨: {num_workers}ä¸ªå·¥ä½œçº¿ç¨‹")
    
    def submit_task(self, task: ITask):
        """æäº¤ä»»åŠ¡"""
        self.task_queue.put(task)
        logger.info(f"ä»»åŠ¡æäº¤: {task.name}")
    
    def shutdown(self):
        """å…³é—­ä»»åŠ¡ç¼–æ’å™¨"""
        self.running = False
        
        for worker in self.workers:
            worker.join()
        
        logger.info("ä»»åŠ¡ç¼–æ’å™¨å…³é—­")

# logic/tasks/base_task.py
class ITask(ABC):
    """ä»»åŠ¡æ¥å£"""
    
    @abstractmethod
    def execute(self) -> Any:
        """æ‰§è¡Œä»»åŠ¡"""
        pass
    
    @property
    @abstractmethod
    def name(self) -> str:
        """ä»»åŠ¡åç§°"""
        pass
    
    @property
    @abstractmethod
    def priority(self) -> int:
        """ä»»åŠ¡ä¼˜å…ˆçº§"""
        pass

# logic/tasks/scan_task.py
class ScanMarketTask(ITask):
    """å¸‚åœºæ‰«æä»»åŠ¡"""
    
    def __init__(self, strategy: BaseStrategy):
        self.strategy = strategy
    
    def execute(self) -> List[Dict]:
        """æ‰§è¡Œä»»åŠ¡"""
        logger.info(f"å¼€å§‹æ‰«æ: {self.name}")
        
        # è·å–å¸‚åœºæ•°æ®
        market_data = get_market_data()
        
        # æ‰§è¡Œç­–ç•¥
        signals = self.strategy.execute(market_data)
        
        logger.info(f"æ‰«æå®Œæˆ: {self.name}, ç”Ÿæˆ{len(signals)}ä¸ªä¿¡å·")
        return signals
    
    @property
    def name(self) -> str:
        return f"{self.strategy.name}_scan"
    
    @property
    def priority(self) -> int:
        return 10  # é«˜ä¼˜å…ˆçº§
```

#### Layer 5: Tools & Scripts (å·¥å…·è„šæœ¬å±‚)

**å°è£…æ–¹å¼**: å•ä¾‹æ¨¡å¼ + å¤–è§‚æ¨¡å¼

```python
# tools/tool_registry.py
class ToolRegistry:
    """å·¥å…·æ³¨å†Œè¡¨"""
    
    _tools = {}
    
    @classmethod
    def register(cls, tool: ITool):
        """æ³¨å†Œå·¥å…·"""
        cls._tools[tool.name] = tool
    
    @classmethod
    def get(cls, name: str) -> ITool:
        """è·å–å·¥å…·"""
        tool = cls._tools.get(name)
        if not tool:
            raise ValueError(f"å·¥å…·ä¸å­˜åœ¨: {name}")
        return tool
    
    @classmethod
    def list_tools(cls) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰å·¥å…·"""
        return list(cls._tools.keys())

# tools/data_fetcher_tool.py
class DataFetcherTool(ITool):
    """æ•°æ®è·å–å·¥å…·"""
    
    def __init__(self):
        self.name = "data_fetcher"
        self.description = "è·å–å¸‚åœºæ•°æ®"
    
    def execute(self, codes: List[str]) -> List[Dict]:
        """æ‰§è¡Œå·¥å…·"""
        data_provider = DataProviderFactory.create_with_fallback('qmt')
        return data_provider.get_realtime_data(codes)
    
    def help(self) -> str:
        """å¸®åŠ©ä¿¡æ¯"""
        return f"{self.name}: {self.description}\n" \
               f"ç”¨æ³•: data_fetcher <codes>\n" \
               f"ç¤ºä¾‹: data_fetcher 000001.SZ 600000.SH"

# è‡ªåŠ¨æ³¨å†Œå·¥å…·
ToolRegistry.register(DataFetcherTool())
```

### 3.2 ä»£ç åˆå¹¶æŠ€æœ¯ç»†èŠ‚

#### 12ä¸ªæ•°æ®åŠ è½½å™¨ â†’ 3ä¸ªpipeline

**ç°æœ‰æ•°æ®åŠ è½½å™¨**:

| åŠ è½½å™¨ | æ–‡ä»¶ | ç”¨é€” | ä¼˜å…ˆçº§ |
|--------|------|------|--------|
| DataManager | logic/data/data_manager.py | é€šç”¨æ•°æ®ç®¡ç† | ğŸ”´ é«˜ |
| RealtimeDataProvider | logic/data/realtime_data_provider.py | å®æ—¶æ•°æ® | ğŸ”´ é«˜ |
| SmartDataManager | logic/data/data_source_manager.py | æ™ºèƒ½æ•°æ®æº | ğŸ”´ é«˜ |
| QMTManager | logic/data/qmt_manager.py | QMTæ•°æ® | ğŸŸ¡ ä¸­ |
| CacheReplayProvider | logic/data/cache_replay_provider.py | å¿«ç…§å›æ”¾ | ğŸŸ¢ ä½ |
| PreMarketCache | logic/pre_market_cache.py | ç›˜å‰ç¼“å­˜ | ğŸŸ¢ ä½ |
| TushareProvider | logic/data/tushare_provider.py | Tushareæ•°æ® | ğŸŸ¢ ä½ |
| AkShareProvider | logic/data/data_adapter_akshare.py | AkShareæ•°æ® | ğŸŸ¢ ä½ |
| EfinanceProvider | logic/data/data_adapter.py | efinanceæ•°æ® | ğŸŸ¢ ä½ |
| MoneyFlowAdapter | logic/data/data_adapter_akshare.py | èµ„é‡‘æµé€‚é… | ğŸŸ¡ ä¸­ |
| HistoricalDataProvider | logic/data/qmt_historical_provider.py | å†å²æ•°æ® | ğŸŸ¢ ä½ |
| FundFlowAnalyzer | logic/fund_flow_analyzer.py | èµ„é‡‘æµåˆ†æ | ğŸŸ¡ ä¸­ |

**åˆå¹¶åçš„3ä¸ªPipeline**:

```python
# logic/pipelines/realtime_data_pipeline.py
class RealtimeDataPipeline:
    """å®æ—¶æ•°æ®ç®¡é“ - åˆå¹¶æ‰€æœ‰å®æ—¶æ•°æ®åŠ è½½å™¨"""
    
    def __init__(self):
        self.providers = [
            QMTProvider(),  # ä¼˜å…ˆQMT
            EasyQuotationProvider(),  # é™çº§EasyQuotation
            TushareProvider()  # æœ€åé™çº§Tushare
        ]
    
    def get_realtime_data(self, codes: List[str]) -> List[Dict]:
        """è·å–å®æ—¶æ•°æ®"""
        for provider in self.providers:
            try:
                data = provider.get_realtime_data(codes)
                if data:
                    logger.info(f"ä½¿ç”¨{provider.name}è·å–æ•°æ®")
                    return data
            except Exception as e:
                logger.warning(f"{provider.name}å¤±è´¥: {e}")
                continue
        
        raise DataProviderError("æ‰€æœ‰æ•°æ®æä¾›è€…å‡å¤±è´¥")

# logic/pipelines/history_data_pipeline.py
class HistoryDataPipeline:
    """å†å²æ•°æ®ç®¡é“ - åˆå¹¶æ‰€æœ‰å†å²æ•°æ®åŠ è½½å™¨"""
    
    def __init__(self):
        self.providers = [
            QMTHistoricalProvider(),  # ä¼˜å…ˆQMT
            TushareProvider(),  # é™çº§Tushare
            CacheReplayProvider()  # æœ€åé™çº§ç¼“å­˜
        ]
    
    def get_history_data(self, code: str, period: str) -> pd.DataFrame:
        """è·å–å†å²æ•°æ®"""
        for provider in self.providers:
            try:
                data = provider.get_history_data(code, period)
                if not data.empty:
                    logger.info(f"ä½¿ç”¨{provider.name}è·å–å†å²æ•°æ®")
                    return data
            except Exception as e:
                logger.warning(f"{provider.name}å¤±è´¥: {e}")
                continue
        
        raise DataProviderError("æ‰€æœ‰å†å²æ•°æ®æä¾›è€…å‡å¤±è´¥")

# logic/pipelines/moneyflow_pipeline.py
class MoneyflowDataPipeline:
    """èµ„é‡‘æµæ•°æ®ç®¡é“ - åˆå¹¶æ‰€æœ‰èµ„é‡‘æµåŠ è½½å™¨"""
    
    def __init__(self):
        self.providers = [
            AkShareMoneyFlowProvider(),  # ä¼˜å…ˆAkShare
            TushareMoneyFlowProvider()  # é™çº§Tushare
        ]
    
    def get_moneyflow(self, code: str, days: int) -> Dict:
        """è·å–èµ„é‡‘æµæ•°æ®"""
        for provider in self.providers:
            try:
                data = provider.get_moneyflow(code, days)
                if data:
                    logger.info(f"ä½¿ç”¨{provider.name}è·å–èµ„é‡‘æµ")
                    return data
            except Exception as e:
                logger.warning(f"{provider.name}å¤±è´¥: {e}")
                continue
        
        raise DataProviderError("æ‰€æœ‰èµ„é‡‘æµæä¾›è€…å‡å¤±è´¥")
```

**åˆå¹¶çš„æŠ€æœ¯éš¾åº¦**: â­â­â­â­ (éœ€è¦å¤„ç†æ•°æ®æ ¼å¼ã€å•ä½ã€å­—æ®µæ˜ å°„)

#### 32ä¸ªç­–ç•¥ â†’ 8ä¸ªcore

**ç°æœ‰ç­–ç•¥æ¨¡å—** (31ä¸ª):

| ç­–ç•¥ | æ–‡ä»¶ | ç±»å‹ | åˆå¹¶åˆ° |
|------|------|------|--------|
| FullMarketScanner | full_market_scanner.py | å…¨å¸‚åœºæ‰«æ | Core1 |
| TripleFunnelScanner | triple_funnel_scanner.py | ä¸‰æŠŠæ–§æ‰«æ | Core1 |
| AuctionEventDetector | auction_event_detector.py | ç«ä»·æ£€æµ‹ | Core2 |
| HalfwayEventDetector | halfway_event_detector.py | åŠè·¯æ£€æµ‹ | Core2 |
| DipBuyEventDetector | dip_buy_event_detector.py | ä½å¸æ£€æµ‹ | Core2 |
| LeaderEventDetector | leader_event_detector.py | é¾™å¤´æ£€æµ‹ | Core2 |
| MidwayStrategy | midway_strategy.py | åŠè·¯ç­–ç•¥ | Core3 |
| DragonTactics | dragon_tactics.py | é¾™å¤´ç­–ç•¥ | Core3 |
| MarketTactics | market_tactics.py | å¸‚åœºç­–ç•¥ | Core3 |
| PredatorSystem | predator_system.py | æ¸¸èµ„æ é£Ÿ | Core4 |
| FakeOrderDetector | fake_order_detector.py | å‡å•æ£€æµ‹ | Core4 |
| OrderImbalance | order_imbalance.py | è®¢å•å¤±è¡¡ | Core4 |
| DynamicThreshold | dynamic_threshold.py | åŠ¨æ€é˜ˆå€¼ | Core5 |
| WindFilter | wind_filter.py | é£å£è¿‡æ»¤ | Core5 |
| AuctionStrengthValidator | auction_strength_validator.py | ç«ä»·æ ¡éªŒ | Core5 |
| BacktestEngine | backtest_engine.py | å›æµ‹å¼•æ“ | Core6 |
| SnapshotBacktestEngine | snapshot_backtest_engine.py | å¿«ç…§å›æµ‹ | Core6 |
| StrategyFactory | strategy_factory.py | ç­–ç•¥å·¥å‚ | Core6 |
| StrategyComparator | strategy_comparator.py | ç­–ç•¥å¯¹æ¯” | Core6 |
| TradeLog | trade_log.py | äº¤æ˜“æ—¥å¿— | Core7 |
| EventRecorder | event_recorder.py | äº‹ä»¶è®°å½• | Core7 |
| BuyPointScanner | buy_point_scanner.py | ä¹°ç‚¹æ‰«æ | Core7 |
| LowSuctionEngine | low_suction_engine.py | ä½å¸å¼•æ“ | Core7 |
| SecondWaveDetector | second_wave_detector.py | äºŒæ³¢æ£€æµ‹ | Core7 |
| MarketScanner | market_scanner.py | å¸‚åœºæ‰«æ | Core8 |
| StrategyOrchestrator | strategy_orchestrator.py | ç­–ç•¥ç¼–æ’ | Core8 |
| StrategyLibrary | strategy_library.py | ç­–ç•¥åº“ | Core8 |
| AuctionTrapDetector | auction_trap_detector.py | ç«ä»·é™·é˜± | Core8 |
| TripleFunnelScannerV121 | triple_funnel_scanner_v121.py | ä¸‰æŠŠæ–§V121 | Core1 |

**åˆå¹¶åçš„8ä¸ªCore**:

```python
# logic/cores/scanning_core.py
class ScanningCore:
    """æ‰«ææ ¸å¿ƒ - åˆå¹¶å…¨å¸‚åœºæ‰«æå’Œä¸‰æŠŠæ–§"""
    
    def __init__(self):
        self.full_scanner = FullMarketScanner()
        self.triple_funnel = TripleFunnelScanner()
    
    def scan_market(self) -> Dict:
        """æ‰«æå¸‚åœº"""
        # å…¨å¸‚åœºæ‰«æ
        market_data = self.full_scanner.scan()
        
        # ä¸‰æŠŠæ–§è¿‡æ»¤
        results = self.triple_funnel.filter(market_data)
        
        return results

# logic/cores/event_detection_core.py
class EventDetectionCore:
    """äº‹ä»¶æ£€æµ‹æ ¸å¿ƒ - åˆå¹¶4ä¸ªäº‹ä»¶æ£€æµ‹å™¨"""
    
    def __init__(self):
        self.auction_detector = AuctionEventDetector()
        self.halfway_detector = HalfwayEventDetector()
        self.dip_buy_detector = DipBuyEventDetector()
        self.leader_detector = LeaderEventDetector()
    
    def detect_events(self, market_data: List[Dict]) -> List[Dict]:
        """æ£€æµ‹äº‹ä»¶"""
        events = []
        
        # å¹¶å‘æ£€æµ‹
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = [
                executor.submit(self.auction_detector.detect, market_data),
                executor.submit(self.halfway_detector.detect, market_data),
                executor.submit(self.dip_buy_detector.detect, market_data),
                executor.submit(self.leader_detector.detect, market_data)
            ]
            
            for future in futures:
                events.extend(future.result())
        
        return events

# logic/cores/strategy_execution_core.py
class StrategyExecutionCore:
    """ç­–ç•¥æ‰§è¡Œæ ¸å¿ƒ - åˆå¹¶3ä¸ªç­–ç•¥"""
    
    def __init__(self):
        self.midway_strategy = MidwayStrategy()
        self.dragon_tactics = DragonTactics()
        self.market_tactics = MarketTactics()
    
    def execute_strategies(self, events: List[Dict]) -> List[Dict]:
        """æ‰§è¡Œç­–ç•¥"""
        signals = []
        
        for event in events:
            if event['type'] == 'HALFWAY':
                signal = self.midway_strategy.execute(event)
            elif event['type'] == 'LEADER':
                signal = self.dragon_tactics.execute(event)
            elif event['type'] == 'MARKET':
                signal = self.market_tactics.execute(event)
            
            if signal:
                signals.append(signal)
        
        return signals

# logic/cores/risk_analysis_core.py
class RiskAnalysisCore:
    """é£é™©åˆ†ææ ¸å¿ƒ - åˆå¹¶3ä¸ªé£é™©æ£€æµ‹"""
    
    def __init__(self):
        self.predator_system = PredatorSystem()
        self.fake_order_detector = FakeOrderDetector()
        self.order_imbalance = OrderImbalance()
    
    def analyze_risk(self, signals: List[Dict]) -> List[Dict]:
        """åˆ†æé£é™©"""
        risk_signals = []
        
        for signal in signals:
            # æ¸¸èµ„æ é£Ÿ
            predator_result = self.predator_system.check(signal)
            signal['predator_risk'] = predator_result['risk']
            
            # å‡å•æ£€æµ‹
            fake_order_result = self.fake_order_detector.detect(signal)
            signal['fake_order_risk'] = fake_order_result['risk']
            
            # è®¢å•å¤±è¡¡
            imbalance_result = self.order_imbalance.check(signal)
            signal['order_imbalance'] = imbalance_result['imbalance']
            
            # ç»¼åˆé£é™©è¯„åˆ†
            signal['total_risk'] = self._calculate_total_risk(signal)
            
            if signal['total_risk'] < 0.7:  # é£é™©é˜ˆå€¼
                risk_signals.append(signal)
        
        return risk_signals

# logic/cores/filter_core.py
class FilterCore:
    """è¿‡æ»¤æ ¸å¿ƒ - åˆå¹¶3ä¸ªè¿‡æ»¤å™¨"""
    
    def __init__(self):
        self.dynamic_threshold = DynamicThreshold()
        self.wind_filter = WindFilter()
        self.auction_validator = AuctionStrengthValidator()
    
    def filter(self, signals: List[Dict]) -> List[Dict]:
        """è¿‡æ»¤ä¿¡å·"""
        filtered_signals = []
        
        for signal in signals:
            # åŠ¨æ€é˜ˆå€¼
            if not self.dynamic_threshold.check(signal):
                continue
            
            # é£å£è¿‡æ»¤
            if not self.wind_filter.check(signal):
                continue
            
            # ç«ä»·æ ¡éªŒ
            if not self.auction_validator.validate(signal):
                continue
            
            filtered_signals.append(signal)
        
        return filtered_signals

# logic/cores/backtest_core.py
class BacktestCore:
    """å›æµ‹æ ¸å¿ƒ - åˆå¹¶3ä¸ªå›æµ‹å¼•æ“"""
    
    def __init__(self):
        self.backtest_engine = BacktestEngine()
        self.snapshot_engine = SnapshotBacktestEngine()
        self.strategy_factory = StrategyFactory()
    
    def run_backtest(self, strategy: str, start_date: str, end_date: str) -> Dict:
        """è¿è¡Œå›æµ‹"""
        # åˆ›å»ºç­–ç•¥
        strategy_instance = self.strategy_factory.create(strategy)
        
        # è¿è¡Œå›æµ‹
        results = self.backtest_engine.run(
            strategy_instance,
            start_date,
            end_date
        )
        
        return results

# logic/cores/logging_core.py
class LoggingCore:
    """æ—¥å¿—æ ¸å¿ƒ - åˆå¹¶4ä¸ªæ—¥å¿—æ¨¡å—"""
    
    def __init__(self):
        self.trade_log = TradeLog()
        self.event_recorder = EventRecorder()
        self.buy_point_scanner = BuyPointScanner()
        self.low_suction_engine = LowSuctionEngine()
    
    def log(self, signal: Dict):
        """è®°å½•ä¿¡å·"""
        # äº¤æ˜“æ—¥å¿—
        self.trade_log.log(signal)
        
        # äº‹ä»¶è®°å½•
        self.event_recorder.record(signal)
        
        # ä¹°ç‚¹æ‰«æ
        if signal['type'] == 'BUY':
            self.buy_point_scanner.scan(signal)
        
        # ä½å¸å¼•æ“
        if signal['type'] == 'LOW_SUCTION':
            self.low_suction_engine.process(signal)

# logic/cores/monitoring_core.py
class MonitoringCore:
    """ç›‘æ§æ ¸å¿ƒ - åˆå¹¶3ä¸ªç›‘æ§æ¨¡å—"""
    
    def __init__(self):
        self.market_scanner = MarketScanner()
        self.strategy_orchestrator = StrategyOrchestrator()
        self.strategy_library = StrategyLibrary()
    
    def monitor(self):
        """ç›‘æ§å¸‚åœº"""
        # å¸‚åœºæ‰«æ
        market_data = self.market_scanner.scan()
        
        # ç­–ç•¥ç¼–æ’
        signals = self.strategy_orchestrator.orchestrate(market_data)
        
        # ç­–ç•¥åº“ç®¡ç†
        self.strategy_library.update(signals)
        
        return signals
```

**åˆå¹¶çš„æŠ€æœ¯éš¾åº¦**: â­â­â­â­â­ (éœ€è¦æ·±åº¦ç†è§£ä¸šåŠ¡é€»è¾‘,ä¿è¯åŠŸèƒ½ä¸å˜)

#### æµ‹è¯•éš¾åº¦

**å•å…ƒæµ‹è¯•** (å¿…é¡»è¦†ç›–>90%):

```python
# tests/cores/test_scanning_core.py
def test_scanning_core():
    """æµ‹è¯•æ‰«ææ ¸å¿ƒ"""
    core = ScanningCore()
    results = core.scan_market()
    
    assert results is not None
    assert 'opportunities' in results
    assert 'watchlist' in results
    assert 'blocked' in results

# tests/cores/test_event_detection_core.py
def test_event_detection_core():
    """æµ‹è¯•äº‹ä»¶æ£€æµ‹æ ¸å¿ƒ"""
    core = EventDetectionCore()
    market_data = get_test_market_data()
    events = core.detect_events(market_data)
    
    assert len(events) > 0
    assert all('type' in event for event in events)

# tests/cores/test_strategy_execution_core.py
def test_strategy_execution_core():
    """æµ‹è¯•ç­–ç•¥æ‰§è¡Œæ ¸å¿ƒ"""
    core = StrategyExecutionCore()
    events = get_test_events()
    signals = core.execute_strategies(events)
    
    assert len(signals) > 0
    assert all('code' in signal for signal in signals)
```

**é›†æˆæµ‹è¯•** (å¿…é¡»è¦†ç›–>80%):

```python
# tests/integration/test_core_integration.py
def test_full_pipeline():
    """æµ‹è¯•å®Œæ•´æµç¨‹"""
    # æ‰«æ
    scanning_core = ScanningCore()
    market_data = scanning_core.scan_market()
    
    # äº‹ä»¶æ£€æµ‹
    event_core = EventDetectionCore()
    events = event_core.detect_events(market_data)
    
    # ç­–ç•¥æ‰§è¡Œ
    strategy_core = StrategyExecutionCore()
    signals = strategy_core.execute_strategies(events)
    
    # é£é™©åˆ†æ
    risk_core = RiskAnalysisCore()
    risk_signals = risk_core.analyze_risk(signals)
    
    # è¿‡æ»¤
    filter_core = FilterCore()
    filtered_signals = filter_core.filter(risk_signals)
    
    assert len(filtered_signals) > 0
```

### 3.3 è·¯å¾„å¼•ç”¨ä¿®å¤

#### `from strategies` â†’ `from logic.strategies`

**æ‰¹é‡ä¿®å¤çš„æŠ€æœ¯æ–¹æ¡ˆ**:

```python
# scripts/fix_imports.py
import os
import re
from pathlib import Path

def fix_imports(root_dir: str):
    """æ‰¹é‡ä¿®å¤å¯¼å…¥è·¯å¾„"""
    # éå†æ‰€æœ‰Pythonæ–‡ä»¶
    for py_file in Path(root_dir).rglob('*.py'):
        with open(py_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # ä¿®å¤å¯¼å…¥
        old_content = content
        content = re.sub(
            r'from strategies\s',
            'from logic.strategies ',
            content
        )
        content = re.sub(
            r'from strategies\.',
            'from logic.strategies.',
            content
        )
        
        # å¦‚æœæœ‰ä¿®æ”¹,å†™å›æ–‡ä»¶
        if content != old_content:
            with open(py_file, 'w', encoding='utf-8') as f:
                f.write(content)
            print(f"âœ… ä¿®å¤: {py_file}")

if __name__ == "__main__":
    fix_imports('E:/MyQuantTool')
```

**éªŒè¯æ–¹æ³•**:

```python
# scripts/verify_imports.py
import sys
import importlib

def verify_imports():
    """éªŒè¯æ‰€æœ‰å¯¼å…¥"""
    # è¯»å–æ‰€æœ‰Pythonæ–‡ä»¶
    py_files = list(Path('E:/MyQuantTool').rglob('*.py'))
    
    for py_file in py_files:
        try:
            # å°è¯•å¯¼å…¥
            module_path = str(py_file).replace('E:/MyQuantTool/', '').replace('/', '.').replace('.py', '')
            importlib.import_module(module_path)
            print(f"âœ… {module_path}")
        except Exception as e:
            print(f"âŒ {module_path}: {e}")

if __name__ == "__main__":
    verify_imports()
```

**å›æ»šç­–ç•¥**:

```python
# scripts/rollback_imports.py
import os
import re
from pathlib import Path
from datetime import datetime

def rollback_imports(root_dir: str):
    """å›æ»šå¯¼å…¥è·¯å¾„ä¿®å¤"""
    # è¯»å–å¤‡ä»½æ–‡ä»¶
    backup_file = Path(root_dir) / 'temp' / f'imports_backup_{datetime.now().strftime("%Y%m%d")}.txt'
    
    if not backup_file.exists():
        print("âŒ å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ¨")
        return
    
    with open(backup_file, 'r', encoding='utf-8') as f:
        backup_content = f.read()
    
    # æ¢å¤æ–‡ä»¶
    for line in backup_content.split('\n'):
        if not line:
            continue
        
        file_path, old_import = line.split('::')
        
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # æ¢å¤æ—§å¯¼å…¥
        content = content.replace('from logic.strategies', old_import)
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"âœ… å›æ»š: {file_path}")

if __name__ == "__main__":
    rollback_imports('E:/MyQuantTool')
```

---

## 4. æŠ€æœ¯å€ºåŠ¡è¯†åˆ«

### 4.1 å¿…é¡»ä¿®å¤çš„æŠ€æœ¯å€ºåŠ¡

#### 1. æ•°æ®æºä¸ä¸€è‡´

**é—®é¢˜æè¿°**:
- QMTã€EasyQuotationã€Tushareã€AkShareæ•°æ®æ ¼å¼ä¸ä¸€è‡´
- å•ä½ä¸ç»Ÿä¸€(å…ƒ/ä¸‡å…ƒ/æ‰‹/è‚¡)
- å­—æ®µå‘½åä¸ç»Ÿä¸€(price/now/lastPrice)
- æ—¶é—´æ ¼å¼ä¸ç»Ÿä¸€(timestamp/time/date)

**å½±å“èŒƒå›´**: ğŸ”´ æé«˜ (å½±å“æ‰€æœ‰æ•°æ®å¤„ç†)

**ä¿®å¤æ–¹æ¡ˆ**:

```python
# logic/data/unified_data_model.py
class UnifiedDataModel:
    """ç»Ÿä¸€æ•°æ®æ¨¡å‹"""
    
    @staticmethod
    def normalize(data: Dict, source: str) -> Dict:
        """æ ‡å‡†åŒ–æ•°æ®"""
        normalized = {
            'code': data.get('code', data.get('symbol', data.get('ts_code'))),
            'name': data.get('name', ''),
            'price': float(data.get('price', data.get('now', data.get('lastPrice', 0)))),
            'volume': UnifiedDataModel._normalize_volume(data, source),
            'amount': UnifiedDataModel._normalize_amount(data, source),
            'change_pct': UnifiedDataModel._normalize_change_pct(data, source),
            'timestamp': UnifiedDataModel._normalize_timestamp(data, source),
            'source': source
        }
        
        return normalized
    
    @staticmethod
    def _normalize_volume(data: Dict, source: str) -> float:
        """æ ‡å‡†åŒ–æˆäº¤é‡"""
        volume = 0
        
        if source == 'qmt':
            volume = data.get('volume', 0) / 100  # è‚¡æ•°è½¬æ‰‹æ•°
        elif source == 'easyquotation':
            volume = data.get('volume', 0)  # å·²ç»æ˜¯æ‰‹æ•°
        elif source == 'tushare':
            volume = data.get('vol', 0)  # å·²ç»æ˜¯æ‰‹æ•°
        
        return float(volume)
    
    @staticmethod
    def _normalize_amount(data: Dict, source: str) -> float:
        """æ ‡å‡†åŒ–æˆäº¤é¢"""
        amount = 0
        
        if source == 'qmt':
            amount = data.get('amount', 0) / 10000  # å…ƒè½¬ä¸‡å…ƒ
        elif source == 'easyquotation':
            amount = data.get('amount', 0)  # å·²ç»æ˜¯ä¸‡å…ƒ
        elif source == 'tushare':
            amount = data.get('amount', 0) / 1000  # å…ƒè½¬ä¸‡å…ƒ
        
        return float(amount)
```

#### 2. é‡å¤ä»£ç 

**é—®é¢˜æè¿°**:
- æ•°æ®è·å–é€»è¾‘é‡å¤(3ä¸ªDataProvider)
- é£é™©æ£€æŸ¥é€»è¾‘é‡å¤(4ä¸ªDetector)
- ä¿¡å·éªŒè¯é€»è¾‘é‡å¤(5ä¸ªValidator)

**å½±å“èŒƒå›´**: ğŸŸ¡ ä¸­ (å½±å“ä»£ç ç»´æŠ¤)

**ä¿®å¤æ–¹æ¡ˆ**:

```python
# logic/common/data_fetcher.py
class DataFetcher:
    """ç»Ÿä¸€æ•°æ®è·å–å™¨"""
    
    def __init__(self):
        self.providers = self._init_providers()
    
    def _init_providers(self) -> List[IDataProvider]:
        """åˆå§‹åŒ–æ•°æ®æä¾›è€…"""
        return [
            QMTProvider(),
            EasyQuotationProvider(),
            TushareProvider()
        ]
    
    def fetch(self, codes: List[str]) -> List[Dict]:
        """è·å–æ•°æ®"""
        for provider in self.providers:
            try:
                data = provider.get_realtime_data(codes)
                if data:
                    return data
            except Exception as e:
                logger.warning(f"{provider.name}å¤±è´¥: {e}")
                continue
        
        raise DataFetchError("æ‰€æœ‰æ•°æ®æä¾›è€…å‡å¤±è´¥")

# logic/common/risk_checker.py
class RiskChecker:
    """ç»Ÿä¸€é£é™©æ£€æŸ¥å™¨"""
    
    def __init__(self):
        self.checkers = self._init_checkers()
    
    def _init_checkers(self) -> List[IRiskChecker]:
        """åˆå§‹åŒ–é£é™©æ£€æŸ¥å™¨"""
        return [
            TrapDetector(),
            PredatorSystem(),
            FakeOrderDetector(),
            OrderImbalance()
        ]
    
    def check(self, signal: Dict) -> Dict:
        """æ£€æŸ¥é£é™©"""
        risks = {}
        
        for checker in self.checkers:
            risk = checker.check(signal)
            risks[checker.name] = risk
        
        return risks
```

#### 3. ç¼ºå°‘æŠ½è±¡å±‚

**é—®é¢˜æè¿°**:
- ç­–ç•¥ç›´æ¥è°ƒç”¨æ•°æ®æº,ç»•è¿‡æŠ½è±¡å±‚
- é£é™©ç®¡ç†å™¨ç›´æ¥è°ƒç”¨ç­–ç•¥,ç¼ºå°‘ç»Ÿä¸€æ¥å£
- æ—¥å¿—è®°å½•åˆ†æ•£åœ¨å„ä¸ªæ¨¡å—

**å½±å“èŒƒå›´**: ğŸ”´ æé«˜ (å½±å“æ¶æ„æ‰©å±•æ€§)

**ä¿®å¤æ–¹æ¡ˆ**:

```python
# logic/interfaces/strategy_interface.py
class IStrategy(ABC):
    """ç­–ç•¥æ¥å£"""
    
    @abstractmethod
    def execute(self, data: Dict) -> Dict:
        """æ‰§è¡Œç­–ç•¥"""
        pass
    
    @abstractmethod
    def get_config(self) -> Dict:
        """è·å–é…ç½®"""
        pass

# logic/interfaces/risk_interface.py
class IRiskManager(ABC):
    """é£é™©ç®¡ç†æ¥å£"""
    
    @abstractmethod
    def check(self, signal: Dict) -> bool:
        """æ£€æŸ¥é£é™©"""
        pass
    
    @abstractmethod
    def get_risk_score(self, signal: Dict) -> float:
        """è·å–é£é™©è¯„åˆ†"""
        pass

# logic/interfaces/logger_interface.py
class ILogger(ABC):
    """æ—¥å¿—æ¥å£"""
    
    @abstractmethod
    def log(self, level: str, message: str, context: Dict):
        """è®°å½•æ—¥å¿—"""
        pass
```

#### 4. é…ç½®åˆ†æ•£

**é—®é¢˜æè¿°**:
- é…ç½®æ–‡ä»¶åˆ†æ•£åœ¨12ä¸ªä½ç½®
- é…ç½®æ ¼å¼ä¸ç»Ÿä¸€(JSON/YAML/Python)
- é…ç½®é‡å¤(åŒæ ·çš„é…ç½®åœ¨å¤šä¸ªæ–‡ä»¶ä¸­)

**å½±å“èŒƒå›´**: ğŸŸ¡ ä¸­ (å½±å“é…ç½®ç®¡ç†)

**ä¿®å¤æ–¹æ¡ˆ**:

```python
# config/unified_config.py
class UnifiedConfig:
    """ç»Ÿä¸€é…ç½®ç®¡ç†"""
    
    def __init__(self):
        self.config = self._load_config()
    
    def _load_config(self) -> Dict:
        """åŠ è½½é…ç½®"""
        # åŠ è½½ä¸»é…ç½®
        main_config = self._load_json('config/config.json')
        
        # åŠ è½½ç³»ç»Ÿé…ç½®
        system_config = self._load_py('config/config_system.py')
        
        # åŠ è½½å¸‚åœºæ‰«æé…ç½®
        scan_config = self._load_json('config/market_scan_config.json')
        
        # åˆå¹¶é…ç½®
        merged_config = {
            **main_config,
            **system_config,
            'market_scan': scan_config
        }
        
        return merged_config
    
    def get(self, key: str, default=None):
        """è·å–é…ç½®"""
        keys = key.split('.')
        value = self.config
        
        for k in keys:
            if isinstance(value, dict):
                value = value.get(k)
            else:
                return default
        
        return value if value is not None else default
    
    def set(self, key: str, value: Any):
        """è®¾ç½®é…ç½®"""
        keys = key.split('.')
        config = self.config
        
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        
        config[keys[-1]] = value
    
    def save(self):
        """ä¿å­˜é…ç½®"""
        self._save_json('config/config.json', self.config)
```

### 4.2 å¯ä»¥å»¶åçš„æŠ€æœ¯å€ºåŠ¡

#### 1. æ€§èƒ½ä¼˜åŒ–

**é—®é¢˜æè¿°**:
- å•æ¬¡è·å–5000åªè‚¡ç¥¨è€—æ—¶18ç§’
- å†…å­˜å ç”¨300MB
- CPUå ç”¨ç‡80%

**å½±å“èŒƒå›´**: ğŸŸ¢ ä½ (ä¸å½±å“åŠŸèƒ½)

**å»¶ååŸå› **:
- å½“å‰æ€§èƒ½å¯ä»¥æ»¡è¶³éœ€æ±‚
- ä¼˜åŒ–æˆæœ¬é«˜,æ”¶ç›Šä½
- éœ€è¦æ·±å…¥æµ‹è¯•

**ä¼˜åŒ–æ–¹æ¡ˆ** (å»¶åå®æ–½):

```python
# logic/optimization/batch_processor.py
class BatchProcessor:
    """æ‰¹é‡å¤„ç†å™¨ - æ€§èƒ½ä¼˜åŒ–"""
    
    def __init__(self, batch_size=500):
        self.batch_size = batch_size
    
    def process(self, codes: List[str]) -> List[Dict]:
        """æ‰¹é‡å¤„ç†"""
        results = []
        
        for i in range(0, len(codes), self.batch_size):
            batch = codes[i:i+self.batch_size]
            batch_results = self._process_batch(batch)
            results.extend(batch_results)
        
        return results
    
    def _process_batch(self, batch: List[str]) -> List[Dict]:
        """å¤„ç†æ‰¹æ¬¡"""
        # ä½¿ç”¨å¤šçº¿ç¨‹
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = [executor.submit(self._get_data, code) for code in batch]
            results = [future.result() for future in futures]
        
        return results
```

#### 2. UIæ”¹è¿›

**é—®é¢˜æè¿°**:
- CLIç•Œé¢ä¸å¤Ÿå‹å¥½
- ç¼ºå°‘å¯è§†åŒ–å›¾è¡¨
- ç¼ºå°‘å®æ—¶ç›‘æ§ç•Œé¢

**å½±å“èŒƒå›´**: ğŸŸ¢ ä½ (ä¸å½±å“åŠŸèƒ½)

**å»¶ååŸå› **:
- CLIç•Œé¢å·²ç»è¶³å¤Ÿä½¿ç”¨
- UIå¼€å‘æˆæœ¬é«˜
- ä¸å½±å“æ ¸å¿ƒåŠŸèƒ½

**æ”¹è¿›æ–¹æ¡ˆ** (å»¶åå®æ–½):

```python
# ui/dashboard.py
class Dashboard:
    """å¯è§†åŒ–ä»ªè¡¨ç›˜"""
    
    def __init__(self):
        self.figures = {}
    
    def show_realtime_monitor(self):
        """æ˜¾ç¤ºå®æ—¶ç›‘æ§"""
        # ä½¿ç”¨Plotlyåˆ›å»ºäº¤äº’å¼å›¾è¡¨
        fig = go.Figure()
        
        # æ·»åŠ Kçº¿å›¾
        fig.add_trace(go.Candlestick(
            x=data['date'],
            open=data['open'],
            high=data['high'],
            low=data['low'],
            close=data['close']
        ))
        
        fig.show()
```

#### 3. æ–‡æ¡£æ›´æ–°

**é—®é¢˜æè¿°**:
- éƒ¨åˆ†æ–‡æ¡£è¿‡æ—¶
- ç¼ºå°‘APIæ–‡æ¡£
- ç¼ºå°‘æ¶æ„å›¾

**å½±å“èŒƒå›´**: ğŸŸ¢ ä½ (ä¸å½±å“åŠŸèƒ½)

**å»¶ååŸå› **:
- æ–‡æ¡£ä¸å½±å“ç³»ç»Ÿè¿è¡Œ
- å¯ä»¥é€æ­¥æ›´æ–°
- ä¼˜å…ˆçº§ä½äºå¼€å‘ä»»åŠ¡

**æ›´æ–°æ–¹æ¡ˆ** (å»¶åå®æ–½):

```markdown
# docs/api/README.md
# APIæ–‡æ¡£

## æ•°æ®æä¾›è€…API

### get_realtime_data(codes)
è·å–å®æ—¶æ•°æ®

**å‚æ•°**:
- codes: è‚¡ç¥¨ä»£ç åˆ—è¡¨

**è¿”å›**:
- List[Dict]: è‚¡ç¥¨æ•°æ®åˆ—è¡¨

**ç¤ºä¾‹**:
```python
from logic.data.data_provider import DataProvider

provider = DataProvider()
data = provider.get_realtime_data(['000001.SZ', '600000.SH'])
```
```

---

## 5. å®æ–½æŠ€æœ¯ç»†èŠ‚

### 5.1 Phase 1: æ•°æ®çº¯åŒ–(Day 1)

#### åˆ é™¤easyquotationçš„æŠ€æœ¯æ­¥éª¤

**Step 1: åˆ›å»ºå¤‡ä»½** (0.5å°æ—¶)

```python
# scripts/backup_easyquotation.py
import shutil
from datetime import datetime

def backup_easyquotation():
    """å¤‡ä»½easyquotation"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_dir = f"archive/easyquotation_backup_{timestamp}"
    
    shutil.copytree('easyquotation', backup_dir)
    print(f"âœ… å¤‡ä»½å®Œæˆ: {backup_dir}")

if __name__ == "__main__":
    backup_easyquotation()
```

**Step 2: åˆ›å»ºå…¼å®¹å±‚** (1å°æ—¶)

```python
# logic/data/easyquotation_adapter.py
class EasyQuotationAdapter:
    """easyquotationå…¼å®¹é€‚é…å™¨"""
    
    def __init__(self):
        self.qmt = get_qmt_manager()
        self._warn_deprecation()
    
    def _warn_deprecation(self):
        """è­¦å‘ŠåºŸå¼ƒ"""
        import warnings
        warnings.warn(
            "easyquotationå·²åºŸå¼ƒ,å°†åœ¨V15.2åˆ é™¤",
            DeprecationWarning,
            stacklevel=2
        )
    
    def use(self, source: str):
        """æ¨¡æ‹Ÿeasyquotation.use()"""
        logger.warning(f"easyquotation.use({source})å·²åºŸå¼ƒ,ä½¿ç”¨QMTæ›¿ä»£")
        return self
    
    def stocks(self, codes: List[str]) -> Dict:
        """æ¨¡æ‹Ÿeasyquotation.stocks()"""
        # ä½¿ç”¨QMTè·å–æ•°æ®
        qmt_codes = [CodeConverter.to_qmt(code) for code in codes]
        qmt_data = self.qmt.get_full_tick(qmt_codes)
        
        # è½¬æ¢ä¸ºeasyquotationæ ¼å¼
        return self._convert_to_easyquotation_format(qmt_data)
    
    def _convert_to_easyquotation_format(self, qmt_data: Dict) -> Dict:
        """è½¬æ¢ä¸ºeasyquotationæ ¼å¼"""
        converted = {}
        
        for qmt_code, data in qmt_data.items():
            code = CodeConverter.to_standard(qmt_code)
            converted[code] = {
                'name': '',
                'now': data.get('lastPrice', 0),
                'open': data.get('open', 0),
                'close': data.get('lastClose', 0),
                'high': data.get('high', 0),
                'low': data.get('low', 0),
                'volume': data.get('volume', 0) * 100,  # æ‰‹æ•°è½¬è‚¡æ•°
                'amount': data.get('amount', 0) * 10000,  # ä¸‡å…ƒè½¬å…ƒ
                'time': datetime.now().strftime('%H:%M:%S')
            }
        
        return converted
```

**Step 3: æ‰¹é‡æ›¿æ¢å¼•ç”¨** (2å°æ—¶)

```python
# scripts/replace_easyquotation.py
import re
from pathlib import Path

def replace_easyquotation(root_dir: str):
    """æ‰¹é‡æ›¿æ¢easyquotationå¼•ç”¨"""
    py_files = Path(root_dir).rglob('*.py')
    
    for py_file in py_files:
        with open(py_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        old_content = content
        
        # æ›¿æ¢import
        content = re.sub(
            r'import easyquotation as eq',
            'from logic.data.easyquotation_adapter import EasyQuotationAdapter',
            content
        )
        
        # æ›¿æ¢use()è°ƒç”¨
        content = re.sub(
            r'eq\.use\([\'"].+?[\'"]\)',
            'EasyQuotationAdapter()',
            content
        )
        
        if content != old_content:
            with open(py_file, 'w', encoding='utf-8') as f:
                f.write(content)
            print(f"âœ… æ›¿æ¢: {py_file}")

if __name__ == "__main__":
    replace_easyquotation('E:/MyQuantTool')
```

**Step 4: æµ‹è¯•éªŒè¯** (2å°æ—¶)

```python
# tests/data/test_easyquotation_replacement.py
def test_easyquotation_adapter():
    """æµ‹è¯•easyquotationé€‚é…å™¨"""
    from logic.data.easyquotation_adapter import EasyQuotationAdapter
    
    adapter = EasyQuotationAdapter()
    data = adapter.stocks(['000001.SZ', '600000.SH'])
    
    assert len(data) == 2
    assert '000001.SZ' in data
    assert 'now' in data['000001.SZ']

def test_data_consistency():
    """æµ‹è¯•æ•°æ®ä¸€è‡´æ€§"""
    from logic.data.easyquotation_adapter import EasyQuotationAdapter
    from logic.data.qmt_manager import get_qmt_manager
    
    adapter = EasyQuotationAdapter()
    qmt = get_qmt_manager()
    
    codes = ['000001.SZ']
    
    eq_data = adapter.stocks(codes)
    qmt_data = qmt.get_full_tick(['000001.SZ'])
    
    # éªŒè¯ä»·æ ¼ä¸€è‡´
    assert abs(eq_data['000001.SZ']['now'] - qmt_data['000001.SZ']['lastPrice']) < 0.01
```

#### æ›¿æ¢ä¸ºQMTçš„æŠ€æœ¯æ–¹æ¡ˆ

**æŠ€æœ¯éš¾ç‚¹**:

1. **æ•°æ®æ ¼å¼è½¬æ¢**: QMTæ ¼å¼â†’EasyQuotationæ ¼å¼
2. **å•ä½è½¬æ¢**: æ‰‹æ•°â†’è‚¡æ•°,ä¸‡å…ƒâ†’å…ƒ
3. **å­—æ®µæ˜ å°„**: lastPriceâ†’now, lastCloseâ†’close

**è§£å†³æ–¹æ¡ˆ**:

```python
# logic/data/qmt_converter.py
class QMTConverter:
    """QMTæ•°æ®è½¬æ¢å™¨"""
    
    @staticmethod
    def to_easyquotation_format(qmt_data: Dict, qmt_code: str) -> Dict:
        """è½¬æ¢ä¸ºeasyquotationæ ¼å¼"""
        return {
            'name': '',
            'now': qmt_data.get('lastPrice', 0),
            'open': qmt_data.get('open', 0),
            'close': qmt_data.get('lastClose', 0),
            'high': qmt_data.get('high', 0),
            'low': qmt_data.get('low', 0),
            'volume': qmt_data.get('volume', 0) * 100,  # æ‰‹æ•°è½¬è‚¡æ•°
            'amount': qmt_data.get('amount', 0) * 10000,  # ä¸‡å…ƒè½¬å…ƒ
            'turnover': 0,  # QMTæ²¡æœ‰æ¢æ‰‹ç‡
            'volume_ratio': 0,  # QMTæ²¡æœ‰é‡æ¯”
            'time': datetime.now().strftime('%H:%M:%S'),
            'percent': ((qmt_data.get('lastPrice', 0) - qmt_data.get('lastClose', 0)) / qmt_data.get('lastClose', 1) * 100),
            'bid1': qmt_data.get('bidPrice', [0, 0, 0, 0, 0])[0] if qmt_data.get('bidPrice') else 0,
            'ask1': qmt_data.get('askPrice', [0, 0, 0, 0, 0])[0] if qmt_data.get('askPrice') else 0,
            'bid1_volume': qmt_data.get('bidVol', [0, 0, 0, 0, 0])[0] * 100 if qmt_data.get('bidVol') else 0,
            'ask1_volume': qmt_data.get('askVol', [0, 0, 0, 0, 0])[0] * 100 if qmt_data.get('askVol') else 0
        }
    
    @staticmethod
    def batch_convert(qmt_data: Dict) -> Dict:
        """æ‰¹é‡è½¬æ¢"""
        converted = {}
        
        for qmt_code, data in qmt_data.items():
            code = CodeConverter.to_standard(qmt_code)
            converted[code] = QMTConverter.to_easyquotation_format(data, qmt_code)
        
        return converted
```

#### Fail-Safeå®ç°çš„æŠ€æœ¯ç»†èŠ‚

**å¿ƒè·³æ£€æµ‹å®ç°**:

```python
# logic/failsafe/heartbeat_monitor.py
class HeartbeatMonitor:
    """å¿ƒè·³ç›‘æ§å™¨"""
    
    def __init__(self, interval=1.0):
        self.interval = interval
        self.qmt_checker = QMTHealthChecker()
        self.data_checker = DataQualityChecker()
        self.anti_false_trigger = AntiFalseTrigger()
        self.running = False
    
    def start(self):
        """å¯åŠ¨å¿ƒè·³ç›‘æ§"""
        self.running = True
        
        while self.running:
            # æ£€æŸ¥QMTè¿æ¥
            qmt_status = self.qmt_checker.check_connection()
            
            # æ£€æŸ¥æ•°æ®è´¨é‡
            data_quality = self.data_checker.check_data_quality(self._get_test_data())
            
            # ç»¼åˆåˆ¤æ–­
            if qmt_status['status'] == 'ERROR':
                if self.anti_false_trigger.check_should_trigger(qmt_status['error']):
                    self._trigger_fail_safe(qmt_status)
            
            time.sleep(self.interval)
    
    def _get_test_data(self) -> Dict:
        """è·å–æµ‹è¯•æ•°æ®"""
        qmt = get_qmt_manager()
        test_data = qmt.get_full_tick(['000001.SZ'])
        
        if test_data and '000001.SZ' in test_data:
            return test_data['000001.SZ']
        
        return {}
    
    def _trigger_fail_safe(self, error: Dict):
        """è§¦å‘Fail-Safe"""
        logger.critical(f"ğŸš¨ Fail-Safeè§¦å‘: {error}")
        
        # åœæ­¢äº¤æ˜“
        self._stop_trading()
        
        # å‘é€å‘Šè­¦
        alert_system = AlertSystem()
        alert_system.send_alert('P0', f"Fail-Safeè§¦å‘: {error}")
        
        # ç­‰å¾…äººå·¥å¹²é¢„
        self._wait_for_manual_intervention()
    
    def _stop_trading(self):
        """åœæ­¢äº¤æ˜“"""
        # ç´§æ€¥å¹³ä»“
        emergency_closer = EmergencyCloser()
        emergency_closer.close_all_positions("Fail-Safeè§¦å‘")
        
        # åœæ­¢æ‰«æ
        stop_all_scanners()
    
    def _wait_for_manual_intervention(self):
        """ç­‰å¾…äººå·¥å¹²é¢„"""
        logger.critical("ç­‰å¾…äººå·¥å¹²é¢„...")
        
        while self.running:
            time.sleep(10)
            
            # æ£€æŸ¥æ˜¯å¦æ¢å¤
            if self._check_recovery():
                logger.info("ç³»ç»Ÿå·²æ¢å¤")
                break
```

**æµ‹è¯•æ–¹æ¡ˆ**:

```python
# tests/failsafe/test_heartbeat_monitor.py
def test_heartbeat_monitor():
    """æµ‹è¯•å¿ƒè·³ç›‘æ§"""
    monitor = HeartbeatMonitor(interval=0.1)
    
    # æ¨¡æ‹ŸQMTæ–­è¿
    with patch.object(monitor.qmt_checker, 'check_connection', return_value={'status': 'ERROR', 'error': 'QMTæ–­è¿'}):
        monitor.start()
        time.sleep(0.5)
        monitor.running = False
    
    # éªŒè¯Fail-Safeè¢«è§¦å‘
    assert fail_safe_triggered

def test_anti_false_trigger():
    """æµ‹è¯•é˜²è¯¯è§¦å‘"""
    anti_false_trigger = AntiFalseTrigger()
    
    # è¿ç»­3æ¬¡é”™è¯¯
    for i in range(3):
        should_trigger = anti_false_trigger.check_should_trigger('QMTæ–­è¿')
    
    assert should_trigger == True
```

### 5.2 Phase 2: ç­–ç•¥ç²¾ç®€(Day 2)

#### 32ä¸ªç­–ç•¥ â†’ 8ä¸ªcoreçš„æŠ€æœ¯æ–¹æ¡ˆ

**åˆå¹¶ç­–ç•¥**:

```python
# logic/cores/core_factory.py
class CoreFactory:
    """æ ¸å¿ƒå·¥å‚"""
    
    _cores = {
        'scanning': ScanningCore,
        'event_detection': EventDetectionCore,
        'strategy_execution': StrategyExecutionCore,
        'risk_analysis': RiskAnalysisCore,
        'filter': FilterCore,
        'backtest': BacktestCore,
        'logging': LoggingCore,
        'monitoring': MonitoringCore
    }
    
    @classmethod
    def create(cls, core_type: str) -> ICore:
        """åˆ›å»ºæ ¸å¿ƒ"""
        core_class = cls._cores.get(core_type)
        if not core_class:
            raise ValueError(f"æœªçŸ¥çš„æ ¸å¿ƒç±»å‹: {core_type}")
        return core_class()
    
    @classmethod
    def create_all(cls) -> Dict[str, ICore]:
        """åˆ›å»ºæ‰€æœ‰æ ¸å¿ƒ"""
        return {
            core_type: cls.create(core_type)
            for core_type in cls._cores
        }
```

**åˆå¹¶çš„æŠ€æœ¯ç»†èŠ‚**:

1. **æ¥å£ç»Ÿä¸€**: æ‰€æœ‰æ ¸å¿ƒå®ç°ICoreæ¥å£
2. **æ•°æ®æµç»Ÿä¸€**: æ‰€æœ‰æ ¸å¿ƒä½¿ç”¨ç›¸åŒçš„æ•°æ®æ ¼å¼
3. **é…ç½®ç»Ÿä¸€**: æ‰€æœ‰æ ¸å¿ƒä½¿ç”¨ç»Ÿä¸€çš„é…ç½®ç®¡ç†
4. **æ—¥å¿—ç»Ÿä¸€**: æ‰€æœ‰æ ¸å¿ƒä½¿ç”¨ç»Ÿä¸€çš„æ—¥å¿—æ¥å£

#### æµ‹è¯•æ–¹æ¡ˆ

```python
# tests/cores/test_core_integration.py
def test_all_cores():
    """æµ‹è¯•æ‰€æœ‰æ ¸å¿ƒ"""
    cores = CoreFactory.create_all()
    
    # æµ‹è¯•æ‰«ææ ¸å¿ƒ
    market_data = cores['scanning'].scan_market()
    assert market_data is not None
    
    # æµ‹è¯•äº‹ä»¶æ£€æµ‹æ ¸å¿ƒ
    events = cores['event_detection'].detect_events(market_data)
    assert len(events) > 0
    
    # æµ‹è¯•ç­–ç•¥æ‰§è¡Œæ ¸å¿ƒ
    signals = cores['strategy_execution'].execute_strategies(events)
    assert len(signals) > 0
    
    # æµ‹è¯•é£é™©åˆ†ææ ¸å¿ƒ
    risk_signals = cores['risk_analysis'].analyze_risk(signals)
    assert len(risk_signals) >= 0
    
    # æµ‹è¯•è¿‡æ»¤æ ¸å¿ƒ
    filtered_signals = cores['filter'].filter(risk_signals)
    assert len(filtered_signals) >= 0
```

### 5.3 Phase 3: æ¶æ„éƒ¨ç½²(Day 3)

#### 5å±‚æ¶æ„çš„æŠ€æœ¯å®ç°

**æ¶æ„è¿ç§»**:

```python
# logic/architecture/architecture_migrator.py
class ArchitectureMigrator:
    """æ¶æ„è¿ç§»å™¨"""
    
    def __init__(self):
        self.cores = CoreFactory.create_all()
    
    def migrate_to_5_layer(self):
        """è¿ç§»åˆ°5å±‚æ¶æ„"""
        # Layer 1: Core Abstractions
        self._setup_layer1()
        
        # Layer 2: Data Pipeline
        self._setup_layer2()
        
        # Layer 3: Strategy Modules
        self._setup_layer3()
        
        # Layer 4: Task Orchestration
        self._setup_layer4()
        
        # Layer 5: Tools & Scripts
        self._setup_layer5()
    
    def _setup_layer1(self):
        """è®¾ç½®Layer 1"""
        # åˆ›å»ºæŠ½è±¡æ¥å£
        self._create_interfaces()
        
        # åˆ›å»ºå·¥å‚
        self._create_factories()
        
        logger.info("âœ… Layer 1: Core Abstractions è®¾ç½®å®Œæˆ")
    
    def _setup_layer2(self):
        """è®¾ç½®Layer 2"""
        # åˆ›å»ºæ•°æ®ç®¡é“
        self._create_pipelines()
        
        logger.info("âœ… Layer 2: Data Pipeline è®¾ç½®å®Œæˆ")
    
    def _setup_layer3(self):
        """è®¾ç½®Layer 3"""
        # åˆ›å»ºç­–ç•¥æ ¸å¿ƒ
        self._create_cores()
        
        logger.info("âœ… Layer 3: Strategy Modules è®¾ç½®å®Œæˆ")
    
    def _setup_layer4(self):
        """è®¾ç½®Layer 4"""
        # åˆ›å»ºä»»åŠ¡ç¼–æ’å™¨
        self._create_orchestrator()
        
        logger.info("âœ… Layer 4: Task Orchestration è®¾ç½®å®Œæˆ")
    
    def _setup_layer5(self):
        """è®¾ç½®Layer 5"""
        # åˆ›å»ºå·¥å…·æ³¨å†Œè¡¨
        self._create_tool_registry()
        
        logger.info("âœ… Layer 5: Tools & Scripts è®¾ç½®å®Œæˆ")
```

#### é…ç½®é›†ä¸­åŒ–

```python
# config/centralized_config.py
class CentralizedConfig:
    """é›†ä¸­åŒ–é…ç½®"""
    
    def __init__(self):
        self.config = self._load_all_configs()
    
    def _load_all_configs(self) -> Dict:
        """åŠ è½½æ‰€æœ‰é…ç½®"""
        # åˆå¹¶æ‰€æœ‰é…ç½®æ–‡ä»¶
        configs = {}
        
        # ä¸»é…ç½®
        configs.update(self._load_json('config/config.json'))
        
        # ç³»ç»Ÿé…ç½®
        configs.update(self._load_py('config/config_system.py'))
        
        # å¸‚åœºæ‰«æé…ç½®
        configs['market_scan'] = self._load_json('config/market_scan_config.json')
        
        # æ•°æ®æºé…ç½®
        configs['data_source'] = self._load_json('config/data_source_config.json')
        
        # ç­–ç•¥é…ç½®
        configs['strategies'] = self._load_json('config/strategies_config.json')
        
        return configs
    
    def get(self, key: str, default=None):
        """è·å–é…ç½®"""
        keys = key.split('.')
        value = self.config
        
        for k in keys:
            if isinstance(value, dict):
                value = value.get(k)
            else:
                return default
        
        return value if value is not None else default
    
    def save(self):
        """ä¿å­˜é…ç½®"""
        self._save_json('config/config.json', self.config)
```

#### æµ‹è¯•æ–¹æ¡ˆ

```python
# tests/architecture/test_5_layer_architecture.py
def test_5_layer_architecture():
    """æµ‹è¯•5å±‚æ¶æ„"""
    migrator = ArchitectureMigrator()
    migrator.migrate_to_5_layer()
    
    # éªŒè¯Layer 1
    assert hasattr(ICore, '__abstractmethods__')
    
    # éªŒè¯Layer 2
    assert hasattr(DataPipeline, 'process')
    
    # éªŒè¯Layer 3
    cores = CoreFactory.create_all()
    assert len(cores) == 8
    
    # éªŒè¯Layer 4
    orchestrator = TaskOrchestrator()
    assert orchestrator.task_queue is not None
    
    # éªŒè¯Layer 5
    tools = ToolRegistry.list_tools()
    assert len(tools) > 0
```

### 5.4 Phase 4: å®ç›˜æ¼”ç»ƒ(Day 4)

#### å®ç›˜æµ‹è¯•çš„æŠ€æœ¯æ–¹æ¡ˆ

**æµ‹è¯•ç¯å¢ƒ**:

```python
# logic/live_test/live_test_environment.py
class LiveTestEnvironment:
    """å®ç›˜æµ‹è¯•ç¯å¢ƒ"""
    
    def __init__(self):
        self.cores = CoreFactory.create_all()
        self.config = CentralizedConfig()
        self.fail_safe = FailSafeSystem()
    
    def setup(self):
        """è®¾ç½®æµ‹è¯•ç¯å¢ƒ"""
        # åŠ è½½é…ç½®
        self.config.load()
        
        # åˆå§‹åŒ–æ ¸å¿ƒ
        self.cores = CoreFactory.create_all()
        
        # å¯åŠ¨Fail-Safe
        self.fail_safe.start()
        
        logger.info("âœ… å®ç›˜æµ‹è¯•ç¯å¢ƒè®¾ç½®å®Œæˆ")
    
    def run_test(self, duration_hours: int = 4):
        """è¿è¡Œæµ‹è¯•"""
        start_time = time.time()
        
        while time.time() - start_time < duration_hours * 3600:
            try:
                # æ‰«æå¸‚åœº
                market_data = self.cores['scanning'].scan_market()
                
                # æ£€æµ‹äº‹ä»¶
                events = self.cores['event_detection'].detect_events(market_data)
                
                # æ‰§è¡Œç­–ç•¥
                signals = self.cores['strategy_execution'].execute_strategies(events)
                
                # åˆ†æé£é™©
                risk_signals = self.cores['risk_analysis'].analyze_risk(signals)
                
                # è¿‡æ»¤ä¿¡å·
                filtered_signals = self.cores['filter'].filter(risk_signals)
                
                # è®°å½•æ—¥å¿—
                for signal in filtered_signals:
                    self.cores['logging'].log(signal)
                
                # ä¼‘çœ 
                time.sleep(60)
                
            except Exception as e:
                logger.error(f"å®ç›˜æµ‹è¯•å¤±è´¥: {e}")
                self.fail_safe.trigger(f"å®ç›˜æµ‹è¯•å¤±è´¥: {e}")
                break
    
    def teardown(self):
        """æ¸…ç†æµ‹è¯•ç¯å¢ƒ"""
        # åœæ­¢Fail-Safe
        self.fail_safe.stop()
        
        # ä¿å­˜æ—¥å¿—
        self.cores['logging'].save()
        
        logger.info("âœ… å®ç›˜æµ‹è¯•ç¯å¢ƒæ¸…ç†å®Œæˆ")
```

#### ç›‘æ§æ–¹æ¡ˆ

```python
# logic/monitoring/live_monitor.py
class LiveMonitor:
    """å®ç›˜ç›‘æ§å™¨"""
    
    def __init__(self):
        self.metrics = {}
        self.alerts = []
    
    def monitor(self, live_test_env: LiveTestEnvironment):
        """ç›‘æ§å®ç›˜æµ‹è¯•"""
        while live_test_env.running:
            # æ”¶é›†æŒ‡æ ‡
            self._collect_metrics(live_test_env)
            
            # æ£€æŸ¥å¼‚å¸¸
            self._check_anomalies()
            
            # å‘é€å‘Šè­¦
            self._send_alerts()
            
            time.sleep(60)
    
    def _collect_metrics(self, env: LiveTestEnvironment):
        """æ”¶é›†æŒ‡æ ‡"""
        self.metrics = {
            'timestamp': time.time(),
            'qmt_status': env.fail_safe.qmt_status,
            'data_quality': env.fail_safe.data_quality,
            'scan_count': env.cores['scanning'].scan_count,
            'event_count': env.cores['event_detection'].event_count,
            'signal_count': env.cores['strategy_execution'].signal_count,
            'risk_count': env.cores['risk_analysis'].risk_count,
            'filtered_count': env.cores['filter'].filtered_count
        }
    
    def _check_anomalies(self):
        """æ£€æŸ¥å¼‚å¸¸"""
        # æ£€æŸ¥QMTçŠ¶æ€
        if self.metrics['qmt_status'] != 'OK':
            self.alerts.append({
                'level': 'P1',
                'message': f"QMTçŠ¶æ€å¼‚å¸¸: {self.metrics['qmt_status']}"
            })
        
        # æ£€æŸ¥æ•°æ®è´¨é‡
        if self.metrics['data_quality'] != 'GOOD':
            self.alerts.append({
                'level': 'P2',
                'message': f"æ•°æ®è´¨é‡å¼‚å¸¸: {self.metrics['data_quality']}"
            })
    
    def _send_alerts(self):
        """å‘é€å‘Šè­¦"""
        for alert in self.alerts:
            alert_system = AlertSystem()
            alert_system.send_alert(alert['level'], alert['message'])
        
        self.alerts = []
```

#### åº”æ€¥æ–¹æ¡ˆ

```python
# logic/emergency/emergency_handler.py
class EmergencyHandler:
    """åº”æ€¥å¤„ç†å™¨"""
    
    def __init__(self):
        self.emergency_contacts = ['13800138000']
        self.emergency_procedures = {
            'QMT_DISCONNECTED': self._handle_qmt_disconnected,
            'DATA_QUALITY_ERROR': self._handle_data_quality_error,
            'SYSTEM_CRASH': self._handle_system_crash
        }
    
    def handle_emergency(self, emergency_type: str, context: Dict):
        """å¤„ç†ç´§æ€¥æƒ…å†µ"""
        logger.critical(f"ğŸš¨ ç´§æ€¥æƒ…å†µ: {emergency_type}")
        
        # æ‰§è¡Œåº”æ€¥ç¨‹åº
        procedure = self.emergency_procedures.get(emergency_type)
        if procedure:
            procedure(context)
        
        # é€šçŸ¥ç´§æ€¥è”ç³»äºº
        self._notify_contacts(emergency_type, context)
    
    def _handle_qmt_disconnected(self, context: Dict):
        """å¤„ç†QMTæ–­è¿"""
        # å°è¯•é‡è¿
        qmt = get_qmt_manager()
        qmt.reconnect()
        
        # å¦‚æœé‡è¿å¤±è´¥,é™çº§åˆ°EasyQuotation
        if not qmt.is_connected():
            logger.warning("QMTé‡è¿å¤±è´¥,é™çº§åˆ°EasyQuotation")
            # ä½¿ç”¨EasyQuotationé€‚é…å™¨
    
    def _handle_data_quality_error(self, context: Dict):
        """å¤„ç†æ•°æ®è´¨é‡é”™è¯¯"""
        # åœæ­¢äº¤æ˜“
        stop_all_trading()
        
        # æ£€æŸ¥æ•°æ®æº
        data_provider = DataProviderFactory.create_with_fallback('qmt')
        
        # éªŒè¯æ•°æ®è´¨é‡
        test_data = data_provider.get_realtime_data(['000001.SZ'])
        if not test_data:
            logger.error("æ•°æ®è´¨é‡æ— æ³•æ¢å¤")
    
    def _handle_system_crash(self, context: Dict):
        """å¤„ç†ç³»ç»Ÿå´©æºƒ"""
        # ç´§æ€¥å¹³ä»“
        emergency_closer = EmergencyCloser()
        emergency_closer.close_all_positions("ç³»ç»Ÿå´©æºƒ")
        
        # ä¿å­˜çŠ¶æ€
        save_system_state()
        
        # é‡å¯ç³»ç»Ÿ
        system_restarter = SystemRestarter()
        system_restarter.hard_restart()
    
    def _notify_contacts(self, emergency_type: str, context: Dict):
        """é€šçŸ¥ç´§æ€¥è”ç³»äºº"""
        message = f"ç´§æ€¥æƒ…å†µ: {emergency_type}\nä¸Šä¸‹æ–‡: {context}"
        
        for contact in self.emergency_contacts:
            send_sms(contact, message)
            send_email(contact, message)
```

---

## 6. æŠ€æœ¯é£é™©ç¼“è§£

### 6.1 æ•°æ®æºåˆ‡æ¢é£é™©

#### QMTæ•…éšœçš„ç¼“è§£æ–¹æ¡ˆ

**é£é™©æè¿°**: QMTå®¢æˆ·ç«¯æ•…éšœ,å¯¼è‡´æ— æ³•è·å–æ•°æ®

**ç¼“è§£æ–¹æ¡ˆ**:

```python
# logic/fallback/qmt_fallback.py
class QMTFallbackHandler:
    """QMTé™çº§å¤„ç†å™¨"""
    
    def __init__(self):
        self.providers = [
            QMTProvider(),
            EasyQuotationProvider(),
            TushareProvider()
        ]
    
    def get_realtime_data(self, codes: List[str]) -> List[Dict]:
        """è·å–å®æ—¶æ•°æ®(å¸¦é™çº§)"""
        for provider in self.providers:
            try:
                data = provider.get_realtime_data(codes)
                if data:
                    logger.info(f"ä½¿ç”¨{provider.name}è·å–æ•°æ®")
                    return data
            except Exception as e:
                logger.warning(f"{provider.name}å¤±è´¥: {e}")
                continue
        
        raise DataProviderError("æ‰€æœ‰æ•°æ®æä¾›è€…å‡å¤±è´¥")
```

**è§¦å‘æ¡ä»¶**:
1. QMTå®¢æˆ·ç«¯æœªè¿æ¥
2. QMTå®¢æˆ·ç«¯å·²ç™»å½•ä½†è¡Œæƒ…ä¸»ç«™æœªè¿æ¥
3. QMTå®¢æˆ·ç«¯å“åº”è¶…æ—¶(>10ç§’)
4. QMTå®¢æˆ·ç«¯è¿”å›æ•°æ®ä¸ºç©º

**å›æ»šæ¡ä»¶**:
1. QMTå®¢æˆ·ç«¯æ¢å¤æ­£å¸¸
2. è¿ç»­5æ¬¡æˆåŠŸè·å–æ•°æ®
3. æ•°æ®è´¨é‡æ£€æŸ¥é€šè¿‡

#### Tushareç§¯åˆ†ä¸è¶³çš„ç¼“è§£æ–¹æ¡ˆ

**é£é™©æè¿°**: Tushareç§¯åˆ†ä¸è¶³,æ— æ³•è·å–æ•°æ®

**ç¼“è§£æ–¹æ¡ˆ**:

```python
# logic/fallback/tushare_fallback.py
class TushareFallbackHandler:
    """Tushareé™çº§å¤„ç†å™¨"""
    
    def __init__(self):
        self.points_monitor = PointsMonitor()
        self.cache = DataCache()
    
    def get_data_with_fallback(self, code: str) -> Dict:
        """è·å–æ•°æ®(å¸¦é™çº§)"""
        # æ£€æŸ¥ç§¯åˆ†
        if not self.points_monitor.has_enough_points():
            logger.warning("Tushareç§¯åˆ†ä¸è¶³,ä½¿ç”¨ç¼“å­˜")
            return self.cache.get(code)
        
        # è·å–æ•°æ®
        try:
            data = self._get_data_from_tushare(code)
            self.cache.put(code, data)
            return data
        except Exception as e:
            logger.error(f"Tushareè·å–æ•°æ®å¤±è´¥: {e}")
            return self.cache.get(code)
    
    def _get_data_from_tushare(self, code: str) -> Dict:
        """ä»Tushareè·å–æ•°æ®"""
        # æ£€æŸ¥ç§¯åˆ†
        if self.points_monitor.get_remaining_points() < 10:
            raise PointsExhaustedError("ç§¯åˆ†ä¸è¶³")
        
        # è·å–æ•°æ®
        data = ts.pro_bar(ts_code=code)
        
        # æ¶ˆè€—ç§¯åˆ†
        self.points_monitor.consume_points(0.1)
        
        return data
```

**è§¦å‘æ¡ä»¶**:
1. Tushareå‰©ä½™ç§¯åˆ†<100
2. Tushare APIè°ƒç”¨å¤±è´¥
3. Tushare APIè¿”å›é™æµé”™è¯¯

**å›æ»šæ¡ä»¶**:
1. Tushareç§¯åˆ†æ¢å¤>500
2. ç§¯åˆ†å……å€¼å®Œæˆ

#### æ•°æ®è´¨é‡ä¸‹é™çš„ç¼“è§£æ–¹æ¡ˆ

**é£é™©æè¿°**: æ•°æ®è´¨é‡ä¸‹é™,å½±å“å†³ç­–å‡†ç¡®æ€§

**ç¼“è§£æ–¹æ¡ˆ**:

```python
# logic/quality/data_quality_monitor.py
class DataQualityMonitor:
    """æ•°æ®è´¨é‡ç›‘æ§å™¨"""
    
    def __init__(self):
        self.quality_history = []
        self.threshold = 0.8  # è´¨é‡é˜ˆå€¼
    
    def check_quality(self, data: List[Dict]) -> float:
        """æ£€æŸ¥æ•°æ®è´¨é‡"""
        quality_score = 0.0
        
        for item in data:
            # æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
            if all(key in item for key in ['code', 'price', 'volume']):
                quality_score += 0.3
            
            # æ£€æŸ¥æ•°æ®åˆç†æ€§
            if item['price'] > 0 and item['volume'] >= 0:
                quality_score += 0.4
            
            # æ£€æŸ¥æ•°æ®æ—¶æ•ˆæ€§
            if time.time() - item.get('timestamp', 0) < 5:
                quality_score += 0.3
        
        # å½’ä¸€åŒ–
        quality_score = quality_score / len(data)
        
        # è®°å½•å†å²
        self.quality_history.append({
            'timestamp': time.time(),
            'quality': quality_score
        })
        
        return quality_score
    
    def is_quality_acceptable(self, data: List[Dict]) -> bool:
        """æ£€æŸ¥æ•°æ®è´¨é‡æ˜¯å¦å¯æ¥å—"""
        quality = self.check_quality(data)
        return quality >= self.threshold
    
    def get_quality_trend(self) -> str:
        """è·å–è´¨é‡è¶‹åŠ¿"""
        if len(self.quality_history) < 3:
            return "UNKNOWN"
        
        recent = self.quality_history[-3:]
        if recent[2]['quality'] > recent[1]['quality'] > recent[0]['quality']:
            return "IMPROVING"
        elif recent[2]['quality'] < recent[1]['quality'] < recent[0]['quality']:
            return "DEGRADING"
        else:
            return "STABLE"
```

**è§¦å‘æ¡ä»¶**:
1. æ•°æ®è´¨é‡è¯„åˆ†<0.8
2. æ•°æ®è´¨é‡è¶‹åŠ¿ä¸º"DEGRADING"
3. è¿ç»­3æ¬¡è´¨é‡æ£€æŸ¥å¤±è´¥

**å›æ»šæ¡ä»¶**:
1. æ•°æ®è´¨é‡è¯„åˆ†>0.9
2. æ•°æ®è´¨é‡è¶‹åŠ¿ä¸º"IMPROVING"
3. è¿ç»­5æ¬¡è´¨é‡æ£€æŸ¥é€šè¿‡

### 6.2 é‡æ„é£é™©

#### åŠŸèƒ½ç¼ºå¤±çš„ç¼“è§£æ–¹æ¡ˆ

**é£é™©æè¿°**: é‡æ„ååŠŸèƒ½ç¼ºå¤±,å¯¼è‡´ç³»ç»Ÿæ— æ³•æ­£å¸¸ä½¿ç”¨

**ç¼“è§£æ–¹æ¡ˆ**:

```python
# logic/verification/feature_verifier.py
class FeatureVerifier:
    """åŠŸèƒ½éªŒè¯å™¨"""
    
    def __init__(self):
        self.feature_list = self._load_feature_list()
        self.verification_results = {}
    
    def verify_all_features(self):
        """éªŒè¯æ‰€æœ‰åŠŸèƒ½"""
        for feature in self.feature_list:
            try:
                result = self._verify_feature(feature)
                self.verification_results[feature['name']] = result
            except Exception as e:
                logger.error(f"åŠŸèƒ½éªŒè¯å¤±è´¥: {feature['name']}, {e}")
                self.verification_results[feature['name']] = {
                    'status': 'FAILED',
                    'error': str(e)
                }
    
    def _verify_feature(self, feature: Dict) -> Dict:
        """éªŒè¯å•ä¸ªåŠŸèƒ½"""
        # è·å–éªŒè¯å‡½æ•°
        verify_func = getattr(self, f"verify_{feature['type']}")
        
        # æ‰§è¡ŒéªŒè¯
        result = verify_func(feature['params'])
        
        return {
            'status': 'PASSED' if result else 'FAILED',
            'timestamp': time.time()
        }
    
    def verify_data_fetch(self, params: Dict) -> bool:
        """éªŒè¯æ•°æ®è·å–"""
        data_provider = DataProviderFactory.create_with_fallback('qmt')
        data = data_provider.get_realtime_data(params['codes'])
        return len(data) > 0
    
    def verify_strategy_execution(self, params: Dict) -> bool:
        """éªŒè¯ç­–ç•¥æ‰§è¡Œ"""
        strategy = params['strategy']
        market_data = params['market_data']
        signals = strategy.execute(market_data)
        return len(signals) >= 0
    
    def verify_risk_check(self, params: Dict) -> bool:
        """éªŒè¯é£é™©æ£€æŸ¥"""
        signal = params['signal']
        risk_manager = RiskManager()
        return risk_manager.check(signal) is not None
    
    def generate_report(self) -> str:
        """ç”ŸæˆéªŒè¯æŠ¥å‘Š"""
        passed = sum(1 for r in self.verification_results.values() if r['status'] == 'PASSED')
        total = len(self.verification_results)
        
        report = f"""
# åŠŸèƒ½éªŒè¯æŠ¥å‘Š

## æ€»ä½“ç»“æœ
- é€šè¿‡: {passed}/{total}
- å¤±è´¥: {total - passed}/{total}
- é€šè¿‡ç‡: {passed/total*100:.1f}%

## è¯¦ç»†ç»“æœ
"""
        
        for feature_name, result in self.verification_results.items():
            status_icon = "âœ…" if result['status'] == 'PASSED' else "âŒ"
            report += f"\n{status_icon} {feature_name}: {result['status']}"
        
        return report
```

**è§¦å‘æ¡ä»¶**:
1. åŠŸèƒ½éªŒè¯å¤±è´¥
2. åŠŸèƒ½æµ‹è¯•è¦†ç›–ç‡<90%
3. å›æµ‹ç»“æœä¸é¢„æœŸä¸ç¬¦

**å›æ»šæ¡ä»¶**:
1. æ‰€æœ‰åŠŸèƒ½éªŒè¯é€šè¿‡
2. åŠŸèƒ½æµ‹è¯•è¦†ç›–ç‡>95%
3. å›æµ‹ç»“æœä¸é¢„æœŸä¸€è‡´

#### æ€§èƒ½ä¸‹é™çš„ç¼“è§£æ–¹æ¡ˆ

**é£é™©æè¿°**: é‡æ„åæ€§èƒ½ä¸‹é™,å¯¼è‡´ç³»ç»Ÿå“åº”å˜æ…¢

**ç¼“è§£æ–¹æ¡ˆ**:

```python
# logic/performance/performance_monitor.py
class PerformanceMonitor:
    """æ€§èƒ½ç›‘æ§å™¨"""
    
    def __init__(self):
        self.metrics = {}
        self.baseline = self._load_baseline()
    
    def measure_performance(self, func_name: str, func: Callable, *args, **kwargs):
        """æµ‹é‡æ€§èƒ½"""
        start_time = time.time()
        result = func(*args, **kwargs)
        elapsed_time = time.time() - start_time
        
        # è®°å½•æŒ‡æ ‡
        self.metrics[func_name] = {
            'elapsed_time': elapsed_time,
            'timestamp': time.time()
        }
        
        # æ£€æŸ¥æ˜¯å¦è¶…å‡ºåŸºå‡†
        if func_name in self.baseline:
            baseline_time = self.baseline[func_name]
            if elapsed_time > baseline_time * 1.2:  # è¶…å‡º20%
                logger.warning(f"æ€§èƒ½ä¸‹é™: {func_name}, {elapsed_time:.2f}s > {baseline_time:.2f}s")
        
        return result
    
    def compare_with_baseline(self) -> Dict:
        """ä¸åŸºå‡†å¯¹æ¯”"""
        comparison = {}
        
        for func_name, metrics in self.metrics.items():
            if func_name in self.baseline:
                baseline_time = self.baseline[func_name]
                current_time = metrics['elapsed_time']
                
                comparison[func_name] = {
                    'baseline': baseline_time,
                    'current': current_time,
                    'change': (current_time - baseline_time) / baseline_time * 100,
                    'status': 'OK' if current_time <= baseline_time * 1.2 else 'DEGRADED'
                }
        
        return comparison
```

**è§¦å‘æ¡ä»¶**:
1. å‡½æ•°æ‰§è¡Œæ—¶é—´è¶…å‡ºåŸºå‡†20%
2. å†…å­˜å ç”¨è¶…å‡ºåŸºå‡†30%
3. CPUå ç”¨ç‡è¶…å‡ºåŸºå‡†50%

**å›æ»šæ¡ä»¶**:
1. æ‰€æœ‰å‡½æ•°æ‰§è¡Œæ—¶é—´åœ¨åŸºå‡†èŒƒå›´å†…
2. å†…å­˜å ç”¨åœ¨åŸºå‡†èŒƒå›´å†…
3. CPUå ç”¨ç‡åœ¨åŸºå‡†èŒƒå›´å†…

#### æµ‹è¯•ä¸å……åˆ†çš„ç¼“è§£æ–¹æ¡ˆ

**é£é™©æè¿°**: æµ‹è¯•ä¸å……åˆ†,å¯¼è‡´é‡æ„åå‡ºç°æœªçŸ¥bug

**ç¼“è§£æ–¹æ¡ˆ**:

```python
# logic/testing/test_runner.py
class TestRunner:
    """æµ‹è¯•è¿è¡Œå™¨"""
    
    def __init__(self):
        self.test_results = {}
        self.coverage = CoverageMonitor()
    
    def run_all_tests(self):
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
        # è¿è¡Œå•å…ƒæµ‹è¯•
        self._run_unit_tests()
        
        # è¿è¡Œé›†æˆæµ‹è¯•
        self._run_integration_tests()
        
        # è¿è¡Œå›æµ‹æµ‹è¯•
        self._run_backtest_tests()
        
        # è®¡ç®—è¦†ç›–ç‡
        self.coverage.calculate()
    
    def _run_unit_tests(self):
        """è¿è¡Œå•å…ƒæµ‹è¯•"""
        test_files = list(Path('tests/unit').rglob('test_*.py'))
        
        for test_file in test_files:
            try:
                result = pytest.main([str(test_file)])
                self.test_results[str(test_file)] = {
                    'type': 'unit',
                    'result': 'PASSED' if result == 0 else 'FAILED'
                }
            except Exception as e:
                logger.error(f"å•å…ƒæµ‹è¯•å¤±è´¥: {test_file}, {e}")
                self.test_results[str(test_file)] = {
                    'type': 'unit',
                    'result': 'ERROR',
                    'error': str(e)
                }
    
    def _run_integration_tests(self):
        """è¿è¡Œé›†æˆæµ‹è¯•"""
        test_files = list(Path('tests/integration').rglob('test_*.py'))
        
        for test_file in test_files:
            try:
                result = pytest.main([str(test_file)])
                self.test_results[str(test_file)] = {
                    'type': 'integration',
                    'result': 'PASSED' if result == 0 else 'FAILED'
                }
            except Exception as e:
                logger.error(f"é›†æˆæµ‹è¯•å¤±è´¥: {test_file}, {e}")
                self.test_results[str(test_file)] = {
                    'type': 'integration',
                    'result': 'ERROR',
                    'error': str(e)
                }
    
    def _run_backtest_tests(self):
        """è¿è¡Œå›æµ‹æµ‹è¯•"""
        backtest_files = list(Path('tests/backtest').rglob('test_*.py'))
        
        for backtest_file in backtest_files:
            try:
                result = pytest.main([str(backtest_file)])
                self.test_results[str(backtest_file)] = {
                    'type': 'backtest',
                    'result': 'PASSED' if result == 0 else 'FAILED'
                }
            except Exception as e:
                logger.error(f"å›æµ‹æµ‹è¯•å¤±è´¥: {backtest_file}, {e}")
                self.test_results[str(backtest_file)] = {
                    'type': 'backtest',
                    'result': 'ERROR',
                    'error': str(e)
                }
    
    def generate_report(self) -> str:
        """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
        total = len(self.test_results)
        passed = sum(1 for r in self.test_results.values() if r['result'] == 'PASSED')
        
        report = f"""
# æµ‹è¯•æŠ¥å‘Š

## æ€»ä½“ç»“æœ
- æ€»æµ‹è¯•æ•°: {total}
- é€šè¿‡: {passed}
- å¤±è´¥: {total - passed}
- é€šè¿‡ç‡: {passed/total*100:.1f}%

## ä»£ç è¦†ç›–ç‡
- æ€»è¦†ç›–ç‡: {self.coverage.total_coverage:.1f}%
- åˆ†æ”¯è¦†ç›–ç‡: {self.coverage.branch_coverage:.1f}%

## è¯¦ç»†ç»“æœ
"""
        
        for test_file, result in self.test_results.items():
            status_icon = "âœ…" if result['result'] == 'PASSED' else "âŒ"
            report += f"\n{status_icon} {test_file}: {result['result']}"
        
        return report
```

**è§¦å‘æ¡ä»¶**:
1. å•å…ƒæµ‹è¯•è¦†ç›–ç‡<90%
2. é›†æˆæµ‹è¯•è¦†ç›–ç‡<80%
3. å›æµ‹æµ‹è¯•è¦†ç›–ç‡<70%

**å›æ»šæ¡ä»¶**:
1. å•å…ƒæµ‹è¯•è¦†ç›–ç‡>95%
2. é›†æˆæµ‹è¯•è¦†ç›–ç‡>85%
3. å›æµ‹æµ‹è¯•è¦†ç›–ç‡>75%

### 6.3 æ—¶é—´è¡¨é£é™©

#### å·¥æœŸå»¶é•¿çš„ç¼“è§£æ–¹æ¡ˆ

**é£é™©æè¿°**: é‡æ„å·¥æœŸå»¶é•¿,æ— æ³•æŒ‰æ—¶å®Œæˆ

**ç¼“è§£æ–¹æ¡ˆ**:

```python
# logic/project/project_manager.py
class ProjectManager:
    """é¡¹ç›®ç®¡ç†å™¨"""
    
    def __init__(self):
        self.phases = self._load_phases()
        self.progress = {}
        self.milestones = {}
    
    def track_progress(self):
        """è·Ÿè¸ªè¿›åº¦"""
        for phase in self.phases:
            phase_progress = self._calculate_phase_progress(phase)
            self.progress[phase['name']] = phase_progress
            
            # æ£€æŸ¥é‡Œç¨‹ç¢‘
            if phase_progress['completed'] >= phase['milestone']:
                self.milestones[phase['name']] = {
                    'achieved': True,
                    'timestamp': time.time()
                }
        
        # ç”Ÿæˆè¿›åº¦æŠ¥å‘Š
        self._generate_progress_report()
    
    def _calculate_phase_progress(self, phase: Dict) -> Dict:
        """è®¡ç®—é˜¶æ®µè¿›åº¦"""
        tasks = phase['tasks']
        completed = sum(1 for task in tasks if task['completed'])
        
        return {
            'total': len(tasks),
            'completed': completed,
            'progress': completed / len(tasks) * 100
        }
    
    def _generate_progress_report(self):
        """ç”Ÿæˆè¿›åº¦æŠ¥å‘Š"""
        report = "# é¡¹ç›®è¿›åº¦æŠ¥å‘Š\n\n"
        
        for phase_name, progress in self.progress.items():
            report += f"## {phase_name}\n"
            report += f"- è¿›åº¦: {progress['completed']}/{progress['total']} ({progress['progress']:.1f}%)\n"
            
            if phase_name in self.milestones:
                report += f"- é‡Œç¨‹ç¢‘: âœ… å·²è¾¾æˆ\n"
            else:
                report += f"- é‡Œç¨‹ç¢‘: â³ æœªè¾¾æˆ\n"
        
        logger.info(report)
```

**è§¦å‘æ¡ä»¶**:
1. æŸä¸ªé˜¶æ®µè¿›åº¦<50%
2. é‡Œç¨‹ç¢‘å»¶è¿Ÿ>3å¤©
3. æ€»ä½“è¿›åº¦<60%

**å›æ»šæ¡ä»¶**:
1. æ‰€æœ‰é˜¶æ®µè¿›åº¦>80%
2. é‡Œç¨‹ç¢‘å»¶è¿Ÿ<1å¤©
3. æ€»ä½“è¿›åº¦>80%

#### è´¨é‡ä¸‹é™çš„ç¼“è§£æ–¹æ¡ˆ

**é£é™©æè¿°**: å·¥æœŸå‹ç¼©å¯¼è‡´è´¨é‡ä¸‹é™

**ç¼“è§£æ–¹æ¡ˆ**:

```python
# logic/quality/quality_assurance.py
class QualityAssurance:
    """è´¨é‡ä¿è¯"""
    
    def __init__(self):
        self.quality_metrics = {}
        self.quality_thresholds = {
            'code_coverage': 90,
            'test_pass_rate': 95,
            'bug_density': 0.1,
            'performance_degradation': 20
        }
    
    def check_quality(self):
        """æ£€æŸ¥è´¨é‡"""
        # ä»£ç è¦†ç›–ç‡
        coverage = self._calculate_code_coverage()
        self.quality_metrics['code_coverage'] = coverage
        
        # æµ‹è¯•é€šè¿‡ç‡
        test_pass_rate = self._calculate_test_pass_rate()
        self.quality_metrics['test_pass_rate'] = test_pass_rate
        
        # bugå¯†åº¦
        bug_density = self._calculate_bug_density()
        self.quality_metrics['bug_density'] = bug_density
        
        # æ€§èƒ½ä¸‹é™
        performance_degradation = self._calculate_performance_degradation()
        self.quality_metrics['performance_degradation'] = performance_degradation
        
        # ç”Ÿæˆè´¨é‡æŠ¥å‘Š
        self._generate_quality_report()
    
    def _calculate_code_coverage(self) -> float:
        """è®¡ç®—ä»£ç è¦†ç›–ç‡"""
        # ä½¿ç”¨coverageå·¥å…·
        coverage = Coverage()
        coverage.start()
        
        # è¿è¡Œæµ‹è¯•
        pytest.main(['tests/'])
        
        coverage.stop()
        return coverage.report()
    
    def _calculate_test_pass_rate(self) -> float:
        """è®¡ç®—æµ‹è¯•é€šè¿‡ç‡"""
        result = pytest.main(['tests/'])
        total_tests = result.tests_collected
        passed_tests = result.tests_passed
        
        return passed_tests / total_tests * 100
    
    def _calculate_bug_density(self) -> float:
        """è®¡ç®—bugå¯†åº¦"""
        # ç»Ÿè®¡bugæ•°é‡
        bug_count = self._count_bugs()
        
        # ç»Ÿè®¡ä»£ç è¡Œæ•°
        code_lines = self._count_code_lines()
        
        return bug_count / code_lines * 1000  # æ¯åƒè¡Œä»£ç çš„bugæ•°
    
    def _calculate_performance_degradation(self) -> float:
        """è®¡ç®—æ€§èƒ½ä¸‹é™"""
        # è¿è¡Œæ€§èƒ½æµ‹è¯•
        baseline_time = self._run_performance_test('baseline')
        current_time = self._run_performance_test('current')
        
        return (current_time - baseline_time) / baseline_time * 100
    
    def _generate_quality_report(self):
        """ç”Ÿæˆè´¨é‡æŠ¥å‘Š"""
        report = "# è´¨é‡æŠ¥å‘Š\n\n"
        
        for metric_name, value in self.quality_metrics.items():
            threshold = self.quality_thresholds[metric_name]
            status = "âœ…" if value >= threshold else "âŒ"
            
            report += f"## {metric_name}\n"
            report += f"- å½“å‰å€¼: {value:.1f}%\n"
            report += f"- é˜ˆå€¼: {threshold}%\n"
            report += f"- çŠ¶æ€: {status}\n"
        
        logger.info(report)
```

**è§¦å‘æ¡ä»¶**:
1. ä»£ç è¦†ç›–ç‡<90%
2. æµ‹è¯•é€šè¿‡ç‡<95%
3. bugå¯†åº¦>0.1
4. æ€§èƒ½ä¸‹é™>20%

**å›æ»šæ¡ä»¶**:
1. ä»£ç è¦†ç›–ç‡>95%
2. æµ‹è¯•é€šè¿‡ç‡>98%
3. bugå¯†åº¦<0.05
4. æ€§èƒ½ä¸‹é™<10%

#### å›æ»šæ–¹æ¡ˆçš„å‡†å¤‡

**é£é™©æè¿°**: é‡æ„å¤±è´¥,éœ€è¦å›æ»šåˆ°ä¹‹å‰ç‰ˆæœ¬

**ç¼“è§£æ–¹æ¡ˆ**:

```python
# logic/rollback/rollback_manager.py
class RollbackManager:
    """å›æ»šç®¡ç†å™¨"""
    
    def __init__(self):
        self.rollback_points = {}
        self.rollback_triggers = {
            'data_source_failure': self._rollback_data_source,
            'feature_loss': self._rollback_features,
            'performance_degradation': self._rollback_performance,
            'quality_degradation': self._rollback_quality
        }
    
    def create_rollback_point(self, phase: str):
        """åˆ›å»ºå›æ»šç‚¹"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        rollback_dir = f"rollback/{phase}_{timestamp}"
        
        # å¤‡ä»½ä»£ç 
        shutil.copytree('logic', f"{rollback_dir}/logic")
        
        # å¤‡ä»½é…ç½®
        shutil.copytree('config', f"{rollback_dir}/config")
        
        # å¤‡ä»½æ•°æ®
        shutil.copytree('data', f"{rollback_dir}/data")
        
        # è®°å½•å›æ»šç‚¹
        self.rollback_points[phase] = {
            'timestamp': timestamp,
            'directory': rollback_dir
        }
        
        logger.info(f"âœ… å›æ»šç‚¹åˆ›å»º: {rollback_dir}")
    
    def trigger_rollback(self, trigger_type: str, reason: str):
        """è§¦å‘å›æ»š"""
        logger.critical(f"ğŸš¨ è§¦å‘å›æ»š: {trigger_type}, åŸå› : {reason}")
        
        # æ‰§è¡Œå›æ»š
        rollback_func = self.rollback_triggers.get(trigger_type)
        if rollback_func:
            rollback_func(reason)
        else:
            logger.error(f"æœªçŸ¥å›æ»šè§¦å‘å™¨: {trigger_type}")
    
    def _rollback_data_source(self, reason: str):
        """å›æ»šæ•°æ®æº"""
        # æ¢å¤easyquotation
        backup_dir = self.rollback_points['data_source']['directory']
        shutil.copytree(f"{backup_dir}/easyquotation", 'easyquotation')
        
        # æ¢å¤æ•°æ®æä¾›è€…
        shutil.copy(f"{backup_dir}/logic/data/data_provider.py", 'logic/data/data_provider.py')
        
        logger.info("âœ… æ•°æ®æºå›æ»šå®Œæˆ")
    
    def _rollback_features(self, reason: str):
        """å›æ»šåŠŸèƒ½"""
        # æ¢å¤ç­–ç•¥æ¨¡å—
        backup_dir = self.rollback_points['features']['directory']
        shutil.copytree(f"{backup_dir}/logic/strategies", 'logic/strategies')
        
        # æ¢å¤æ ¸å¿ƒæ¨¡å—
        shutil.copytree(f"{backup_dir}/logic/cores", 'logic/cores')
        
        logger.info("âœ… åŠŸèƒ½å›æ»šå®Œæˆ")
    
    def _rollback_performance(self, reason: str):
        """å›æ»šæ€§èƒ½"""
        # æ¢å¤æ•°æ®ç®¡é“
        backup_dir = self.rollback_points['performance']['directory']
        shutil.copytree(f"{backup_dir}/logic/pipelines", 'logic/pipelines')
        
        # æ¢å¤ç¼“å­˜
        shutil.copytree(f"{backup_dir}/logic/cache", 'logic/cache')
        
        logger.info("âœ… æ€§èƒ½å›æ»šå®Œæˆ")
    
    def _rollback_quality(self, reason: str):
        """å›æ»šè´¨é‡"""
        # æ¢å¤å®Œæ•´ä»£ç 
        backup_dir = self.rollback_points['quality']['directory']
        shutil.copytree(f"{backup_dir}/logic", 'logic')
        
        # æ¢å¤æµ‹è¯•
        shutil.copytree(f"{backup_dir}/tests", 'tests')
        
        logger.info("âœ… è´¨é‡å›æ»šå®Œæˆ")
```

**å›æ»šè§¦å‘æ¡ä»¶**:
1. æ•°æ®æºåˆ‡æ¢å¤±è´¥,è¿ç»­3æ¬¡æ— æ³•è·å–æ•°æ®
2. åŠŸèƒ½éªŒè¯å¤±è´¥,æ ¸å¿ƒåŠŸèƒ½ç¼ºå¤±
3. æ€§èƒ½ä¸‹é™>50%,ç³»ç»Ÿæ— æ³•æ­£å¸¸ä½¿ç”¨
4. è´¨é‡ä¸‹é™ä¸¥é‡,bugå¯†åº¦>0.5

**å›æ»šæ‰§è¡Œæ­¥éª¤**:
1. åœæ­¢ç³»ç»Ÿ
2. é€‰æ‹©æœ€è¿‘çš„å›æ»šç‚¹
3. æ¢å¤ä»£ç å’Œé…ç½®
4. æ¢å¤æ•°æ®
5. é‡å¯ç³»ç»Ÿ
6. éªŒè¯å›æ»šç»“æœ

---

## 7. æœ€ç»ˆæŠ€æœ¯å»ºè®®

### 7.1 æ¨èå“ªä¸ªæŠ€æœ¯æ–¹æ¡ˆ?

**æ¨èæ–¹æ¡ˆ**: âš ï¸ **ä¿®æ”¹ç‰ˆæ¸è¿›å¼é‡æ„æ–¹æ¡ˆ**

**æ ¸å¿ƒåŸåˆ™**:
1. **ä¸åˆ é™¤,åªæ›¿æ¢**: ä¿ç•™easyquotationä½œä¸ºå¤‡ç”¨,é€æ­¥æ›¿æ¢
2. **ä¸åˆå¹¶,åªå°è£…**: ä¿ç•™ç°æœ‰ç­–ç•¥æ¨¡å—,é€šè¿‡Coreå°è£…
3. **ä¸é‡æ„,åªä¼˜åŒ–**: ä¿ç•™ç°æœ‰æ¶æ„,é€šè¿‡æ¥å£ä¼˜åŒ–

### 7.2 ä¸ºä»€ä¹ˆ?

**åŸå› 1: é£é™©å¯æ§**
- æ¸è¿›å¼æ›¿æ¢,æ¯æ¬¡åªæ”¹ä¸€å°éƒ¨åˆ†
- ä¿ç•™å¤‡ç”¨æ•°æ®æº,é¿å…å•ç‚¹æ•…éšœ
- ä¿ç•™å‘åå…¼å®¹,ä¸å½±å“ç°æœ‰åŠŸèƒ½

**åŸå› 2: æ—¶é—´å¯è¡Œ**
- åˆ†é˜¶æ®µå®æ–½,æ¯ä¸ªé˜¶æ®µ1-3å¤©
- å¯ä»¥å¹¶è¡Œå¼€å‘,æé«˜æ•ˆç‡
- å¯ä»¥éšæ—¶æš‚åœ,ä¸ä¼šå½±å“ç³»ç»Ÿ

**åŸå› 3: è´¨é‡ä¿è¯**
- æ¯ä¸ªé˜¶æ®µéƒ½æœ‰å®Œæ•´çš„æµ‹è¯•
- æ¯ä¸ªé˜¶æ®µéƒ½æœ‰å›æ»šç‚¹
- æ¯ä¸ªé˜¶æ®µéƒ½æœ‰éªŒè¯æŠ¥å‘Š

### 7.3 æ‰§è¡Œè·¯å¾„æ˜¯ä»€ä¹ˆ?

**Phase 0: å‡†å¤‡é˜¶æ®µ** (2-3å¤©)

```python
# tasks/phase0_preparation.py
class Phase0Preparation:
    """é˜¶æ®µ0: å‡†å¤‡"""
    
    def execute(self):
        """æ‰§è¡Œå‡†å¤‡"""
        # Step 1: åˆ›å»ºå›æ»šç‚¹
        self._create_rollback_point('phase0')
        
        # Step 2: å¤‡ä»½æ•°æ®
        self._backup_data()
        
        # Step 3: å»ºç«‹æµ‹è¯•ç¯å¢ƒ
        self._setup_test_environment()
        
        # Step 4: ç¼–å†™æµ‹è¯•ç”¨ä¾‹
        self._write_test_cases()
        
        logger.info("âœ… Phase 0 å®Œæˆ")
```

**Phase 1: Fail-Safeæœºåˆ¶** (2-3å¤©)

```python
# tasks/phase1_failsafe.py
class Phase1FailSafe:
    """é˜¶æ®µ1: Fail-Safeæœºåˆ¶"""
    
    def execute(self):
        """æ‰§è¡ŒFail-Safeæœºåˆ¶"""
        # Step 1: åˆ›å»ºå›æ»šç‚¹
        self._create_rollback_point('phase1')
        
        # Step 2: å®ç°å¿ƒè·³æ£€æµ‹
        self._implement_heartbeat()
        
        # Step 3: å®ç°Kill Switch
        self._implement_kill_switch()
        
        # Step 4: å®ç°å‘Šè­¦ç³»ç»Ÿ
        self._implement_alert_system()
        
        # Step 5: æµ‹è¯•éªŒè¯
        self._test_failsafe()
        
        logger.info("âœ… Phase 1 å®Œæˆ")
```

**Phase 2: æ•°æ®æºä¼˜åŒ–** (3-5å¤©)

```python
# tasks/phase2_data_source.py
class Phase2DataSource:
    """é˜¶æ®µ2: æ•°æ®æºä¼˜åŒ–"""
    
    def execute(self):
        """æ‰§è¡Œæ•°æ®æºä¼˜åŒ–"""
        # Step 1: åˆ›å»ºå›æ»šç‚¹
        self._create_rollback_point('phase2')
        
        # Step 2: åˆ›å»ºQMTä¼˜å…ˆæ•°æ®æº
        self._create_qmt_priority_provider()
        
        # Step 3: åˆ›å»ºå…¼å®¹å±‚
        self._create_compatibility_layer()
        
        # Step 4: ä¼˜åŒ–æ•°æ®ç®¡é“
        self._optimize_data_pipeline()
        
        # Step 5: æµ‹è¯•éªŒè¯
        self._test_data_source()
        
        logger.info("âœ… Phase 2 å®Œæˆ")
```

**Phase 3: ç­–ç•¥æ¨¡å—åŒ–** (5-7å¤©)

```python
# tasks/phase3_strategy.py
class Phase3Strategy:
    """é˜¶æ®µ3: ç­–ç•¥æ¨¡å—åŒ–"""
    
    def execute(self):
        """æ‰§è¡Œç­–ç•¥æ¨¡å—åŒ–"""
        # Step 1: åˆ›å»ºå›æ»šç‚¹
        self._create_rollback_point('phase3')
        
        # Step 2: åˆ›å»ºæ ¸å¿ƒæ¥å£
        self._create_core_interfaces()
        
        # Step 3: å°è£…ç°æœ‰ç­–ç•¥
        self._wrap_existing_strategies()
        
        # Step 4: åˆ›å»ºæ ¸å¿ƒå·¥å‚
        self._create_core_factory()
        
        # Step 5: æµ‹è¯•éªŒè¯
        self._test_strategies()
        
        logger.info("âœ… Phase 3 å®Œæˆ")
```

**Phase 4: æ¶æ„ä¼˜åŒ–** (3-5å¤©)

```python
# tasks/phase4_architecture.py
class Phase4Architecture:
    """é˜¶æ®µ4: æ¶æ„ä¼˜åŒ–"""
    
    def execute(self):
        """æ‰§è¡Œæ¶æ„ä¼˜åŒ–"""
        # Step 1: åˆ›å»ºå›æ»šç‚¹
        self._create_rollback_point('phase4')
        
        # Step 2: å®ç°æ•°æ®ç®¡é“
        self._implement_data_pipeline()
        
        # Step 3: å®ç°ä»»åŠ¡ç¼–æ’
        self._implement_task_orchestration()
        
        # Step 4: é›†ä¸­åŒ–é…ç½®
        self._centralize_config()
        
        # Step 5: æµ‹è¯•éªŒè¯
        self._test_architecture()
        
        logger.info("âœ… Phase 4 å®Œæˆ")
```

**Phase 5: å…¨é¢æµ‹è¯•** (2-3å¤©)

```python
# tasks/phase5_testing.py
class Phase5Testing:
    """é˜¶æ®µ5: å…¨é¢æµ‹è¯•"""
    
    def execute(self):
        """æ‰§è¡Œå…¨é¢æµ‹è¯•"""
        # Step 1: å•å…ƒæµ‹è¯•
        self._run_unit_tests()
        
        # Step 2: é›†æˆæµ‹è¯•
        self._run_integration_tests()
        
        # Step 3: å›æµ‹æµ‹è¯•
        self._run_backtest_tests()
        
        # Step 4: æ€§èƒ½æµ‹è¯•
        self._run_performance_tests()
        
        # Step 5: å®ç›˜æµ‹è¯•
        self._run_live_test()
        
        # Step 6: ç”ŸæˆæŠ¥å‘Š
        self._generate_report()
        
        logger.info("âœ… Phase 5 å®Œæˆ")
```

**æ€»å·¥æœŸ**: 15-23å¤©

---

## 8. æ€»ç»“

### 8.1 å…³é”®å‘ç°

1. **CTOæ–¹æ¡ˆè¿‡äºæ¿€è¿›**: 4å¤©å®Œæˆå¦‚æ­¤å¤§è§„æ¨¡é‡æ„æ˜¯ä¸å¯èƒ½çš„,å®é™…éœ€è¦2-3å‘¨
2. **æ•°æ®æºåˆ‡æ¢é£é™©é«˜**: ç›´æ¥åˆ é™¤easyquotationä¼šå¯¼è‡´ç³»ç»Ÿå´©æºƒ,å¿…é¡»ä¿ç•™å¤‡ç”¨
3. **Fail-Safeæœºåˆ¶å¯è¡Œ**: å¯ä»¥åŸºäºç°æœ‰QMT Managerå®ç°,æŠ€æœ¯éš¾åº¦ä¸­ç­‰
4. **æ¶æ„é‡æ„éœ€è¦æ¸è¿›**: 5å±‚æ¶æ„ä¸ç°æœ‰3å±‚æ¶æ„å…¼å®¹,å¯æ¸è¿›å¼è¿ç§»
5. **æµ‹è¯•è¦†ç›–ç‡ä¸è¶³**: ç°æœ‰æµ‹è¯•è¦†ç›–ç‡<20%,é‡æ„åéœ€è¦è¡¥å……å¤§é‡å•å…ƒæµ‹è¯•

### 8.2 æœ€ç»ˆå»ºè®®

**æ‰§è¡Œè·¯å¾„**: ä¿®æ”¹ç‰ˆæ¸è¿›å¼é‡æ„æ–¹æ¡ˆ (15-23å¤©)

**å…³é”®åŸåˆ™**:
1. ä¸åˆ é™¤,åªæ›¿æ¢
2. ä¸åˆå¹¶,åªå°è£…
3. ä¸é‡æ„,åªä¼˜åŒ–
4. æ¯ä¸ªé˜¶æ®µéƒ½æœ‰å›æ»šç‚¹
5. æ¯ä¸ªé˜¶æ®µéƒ½æœ‰å®Œæ•´æµ‹è¯•

**é£é™©æ§åˆ¶**:
1. ä¿ç•™easyquotationä½œä¸ºå¤‡ç”¨
2. å®ç°Fail-Safeæœºåˆ¶
3. å»ºç«‹å®Œæ•´çš„æµ‹è¯•ä½“ç³»
4. åˆ›å»ºå›æ»šç‚¹
5. ç›‘æ§ç³»ç»Ÿæ€§èƒ½å’Œè´¨é‡

**è´¨é‡ä¿è¯**:
1. å•å…ƒæµ‹è¯•è¦†ç›–ç‡>95%
2. é›†æˆæµ‹è¯•è¦†ç›–ç‡>85%
3. å›æµ‹æµ‹è¯•è¦†ç›–ç‡>75%
4. ä»£ç è¦†ç›–ç‡>90%
5. æµ‹è¯•é€šè¿‡ç‡>98%

### 8.3 ä¸‹ä¸€æ­¥è¡ŒåŠ¨

**ç«‹å³æ‰§è¡Œ** (ä»Šå¤©):
1. [ ] åˆ›å»ºPhase 0å›æ»šç‚¹
2. [ ] å¤‡ä»½æ‰€æœ‰æ•°æ®
3. [ ] å»ºç«‹æµ‹è¯•ç¯å¢ƒ
4. [ ] ç¼–å†™æµ‹è¯•ç”¨ä¾‹

**æœ¬å‘¨å®Œæˆ**:
5. [ ] Phase 1: Fail-Safeæœºåˆ¶
6. [ ] Phase 2: æ•°æ®æºä¼˜åŒ–

**ä¸‹å‘¨å¼€å§‹**:
7. [ ] Phase 3: ç­–ç•¥æ¨¡å—åŒ–
8. [ ] Phase 4: æ¶æ„ä¼˜åŒ–
9. [ ] Phase 5: å…¨é¢æµ‹è¯•

---

**æŠ¥å‘Šç”Ÿæˆæ—¶é—´**: 2026å¹´2æœˆ15æ—¥
**è¯„ä¼°ä¸“å®¶**: AIå¼€å‘ä¸“å®¶
**CTO**: iFlow CLI
**çŠ¶æ€**: å¾…å®¡é˜…
**å»ºè®®æ‰§è¡Œè·¯å¾„**: ä¿®æ”¹ç‰ˆæ¸è¿›å¼é‡æ„æ–¹æ¡ˆ (15-23å¤©)